/*
@stardazed/streams-polyfill - drop-in polyfill for Web Streams with fetch and encoding integration
Part of Stardazed
(c) 2018-Present by @zenmumbler
https://github.com/stardazed/sd-streams
*/
(function(){"use strict";const state_=Symbol("state_"),storedError_=Symbol("storedError_");function isInteger(t){if(!isFinite(t))return!1;const i=Math.abs(t);return Math.floor(i)===i}function isFiniteNonNegativeNumber(t){return!("number"!=typeof t||!isFinite(t))&&t>=0}function isAbortSignal(t){if("object"!=typeof t||null===t)return!1;try{return Object.getOwnPropertyDescriptor(AbortSignal.prototype,"aborted").get.call(t),!0}catch(i){return!1}}function invokeOrNoop(t,i,a){const n=t[i];if(void 0!==n)return Function.prototype.apply.call(n,t,a)}function cloneArrayBuffer(t,i,a,n){return t.slice(i,i+a)}function transferArrayBuffer(t){return t.slice(0)}function copyDataBlockBytes(t,i,a,n,o){new Uint8Array(t,i,o).set(new Uint8Array(a,n,o))}const objectCloneMemo=new WeakMap;let sharedArrayBufferSupported_;function supportsSharedArrayBuffer(){if(void 0===sharedArrayBufferSupported_)try{new SharedArrayBuffer(16),sharedArrayBufferSupported_=!0}catch(t){sharedArrayBufferSupported_=!1}return sharedArrayBufferSupported_}function cloneValue(t){switch(typeof t){case"number":case"string":case"boolean":case"undefined":case"bigint":return t;case"object":{if(objectCloneMemo.has(t))return objectCloneMemo.get(t);if(null===t)return t;if(t instanceof Date)return new Date(t.valueOf());if(t instanceof RegExp)return new RegExp(t);if(supportsSharedArrayBuffer()&&t instanceof SharedArrayBuffer)return t;if(t instanceof ArrayBuffer){const i=cloneArrayBuffer(t,0,t.byteLength);return objectCloneMemo.set(t,i),i}if(ArrayBuffer.isView(t)){const i=cloneValue(t.buffer);let a;return a=t instanceof DataView?t.byteLength:t.length,new t.constructor(i,t.byteOffset,a)}if(t instanceof Map){const i=new Map;return objectCloneMemo.set(t,i),t.forEach(((t,a)=>i.set(a,cloneValue(t)))),i}if(t instanceof Set){const i=new Map;return objectCloneMemo.set(t,i),t.forEach(((t,a)=>i.set(a,cloneValue(t)))),i}const i={};objectCloneMemo.set(t,i);const a=Object.getOwnPropertyNames(t);for(const n of a)i[n]=cloneValue(t[n]);return i}case"symbol":case"function":default:throw new DOMException("Uncloneable value in stream","DataCloneError")}}function promiseCall(t,i,a){try{const n=Function.prototype.apply.call(t,i,a);return Promise.resolve(n)}catch(n){return Promise.reject(n)}}function createAlgorithmFromUnderlyingMethod(t,i,a){const n=t[i];if(void 0===n)return()=>Promise.resolve(void 0);if("function"!=typeof n)throw new TypeError(`Field "${i}" is not a function.`);return function(...i){return promiseCall(n,t,i.concat(a))}}function validateAndNormalizeHighWaterMark(t){const i=Number(t);if(isNaN(i)||i<0)throw new RangeError("highWaterMark must be a valid, non-negative integer.");return i}function makeSizeAlgorithmFromSizeFunction(t){if("function"!=typeof t&&void 0!==t)throw new TypeError("size function must be undefined or a function");return function(i){return"function"==typeof t?t(i):1}}function createControlledPromise(){const t={state:0};return t.promise=new Promise((function(i,a){t.resolve=function(a){t.state=1,i(a)},t.reject=function(i){t.state=2,a(i)}})),t}const CHUNK_SIZE=16384;class QueueImpl{constructor(){this.chunks_=[[]],this.readChunk_=this.writeChunk_=this.chunks_[0],this.length_=0}push(t){this.writeChunk_.push(t),this.length_+=1,this.writeChunk_.length===CHUNK_SIZE&&(this.writeChunk_=[],this.chunks_.push(this.writeChunk_))}front(){if(0!==this.length_)return this.readChunk_[0]}shift(){if(0===this.length_)return;const t=this.readChunk_.shift();return this.length_-=1,0===this.readChunk_.length&&this.readChunk_!==this.writeChunk_&&(this.chunks_.shift(),this.readChunk_=this.chunks_[0]),t}get length(){return this.length_}}const queue_=Symbol("queue_"),queueTotalSize_=Symbol("queueTotalSize_");function dequeueValue(t){const i=t[queue_].shift(),a=t[queueTotalSize_]-i.size;return t[queueTotalSize_]=Math.max(0,a),i.value}function enqueueValueWithSize(t,i,a){if(!isFiniteNonNegativeNumber(a))throw new RangeError("Chunk size must be a non-negative, finite numbers");t[queue_].push({value:i,size:a}),t[queueTotalSize_]+=a}function peekQueueValue(t){return t[queue_].front().value}function resetQueue(t){t[queue_]=new QueueImpl,t[queueTotalSize_]=0}const controlledReadableStream_=Symbol("controlledReadableStream_"),pullAlgorithm_=Symbol("pullAlgorithm_"),cancelAlgorithm_=Symbol("cancelAlgorithm_"),strategySizeAlgorithm_=Symbol("strategySizeAlgorithm_"),strategyHWM_=Symbol("strategyHWM_"),started_=Symbol("started_"),closeRequested_=Symbol("closeRequested_"),pullAgain_=Symbol("pullAgain_"),pulling_=Symbol("pulling_"),cancelSteps_=Symbol("cancelSteps_"),pullSteps_=Symbol("pullSteps_"),autoAllocateChunkSize_=Symbol("autoAllocateChunkSize_"),byobRequest_=Symbol("byobRequest_"),controlledReadableByteStream_=Symbol("controlledReadableByteStream_"),pendingPullIntos_=Symbol("pendingPullIntos_"),closedPromise_=Symbol("closedPromise_"),ownerReadableStream_=Symbol("ownerReadableStream_"),readRequests_=Symbol("readRequests_"),readIntoRequests_=Symbol("readIntoRequests_"),associatedReadableByteStreamController_=Symbol("associatedReadableByteStreamController_"),view_=Symbol("view_"),reader_=Symbol("reader_"),readableStreamController_=Symbol("readableStreamController_");function initializeReadableStream(t){t[state_]="readable",t[reader_]=void 0,t[storedError_]=void 0,t[readableStreamController_]=void 0}function isReadableStream(t){return"object"==typeof t&&null!==t&&readableStreamController_ in t}function isReadableStreamLocked(t){return void 0!==t[reader_]}function readableStreamGetNumReadIntoRequests(t){const i=t[reader_];return void 0===i?0:i[readIntoRequests_].length}function readableStreamGetNumReadRequests(t){const i=t[reader_];return void 0===i?0:i[readRequests_].length}function readableStreamCreateReadResult(t,i,a){const n=a?Object.prototype:null,o=Object.create(n);return o.value=t,o.done=i,o}function readableStreamAddReadIntoRequest(t,i){const a=t[reader_],n=createControlledPromise();return n.forAuthorCode=i,a[readIntoRequests_].push(n),n.promise}function readableStreamAddReadRequest(t,i){const a=t[reader_],n=createControlledPromise();return n.forAuthorCode=i,a[readRequests_].push(n),n.promise}function readableStreamHasBYOBReader(t){return isReadableStreamBYOBReader(t[reader_])}function readableStreamHasDefaultReader(t){return isReadableStreamDefaultReader(t[reader_])}function readableStreamCancel(t,i){if("closed"===t[state_])return Promise.resolve(void 0);if("errored"===t[state_])return Promise.reject(t[storedError_]);readableStreamClose(t);return t[readableStreamController_][cancelSteps_](i).then((t=>{}))}function readableStreamClose(t){t[state_]="closed";const i=t[reader_];if(void 0!==i&&(i[closedPromise_].resolve(),i[closedPromise_].promise.catch((()=>{})),isReadableStreamDefaultReader(i))){for(const t of i[readRequests_])t.resolve(readableStreamCreateReadResult(void 0,!0,t.forAuthorCode));i[readRequests_]=[]}}function readableStreamError(t,i){if("readable"!==t[state_])throw new RangeError("Stream is in an invalid state");t[state_]="errored",t[storedError_]=i;const a=t[reader_];if(void 0!==a)if(a[closedPromise_].reject(i),isReadableStreamDefaultReader(a)){for(const t of a[readRequests_])t.reject(i);a[readRequests_]=[]}else{const t=a[readIntoRequests_];for(const a of t)a.reject(i);a[readIntoRequests_]=[]}}function isReadableStreamDefaultReader(t){return"object"==typeof t&&null!==t&&readRequests_ in t}function isReadableStreamBYOBReader(t){return"object"==typeof t&&null!==t&&readIntoRequests_ in t}function readableStreamReaderGenericInitialize(t,i){t[ownerReadableStream_]=i,i[reader_]=t;const a=i[state_];t[closedPromise_]=createControlledPromise(),"readable"===a||("closed"===a?t[closedPromise_].resolve(void 0):(t[closedPromise_].reject(i[storedError_]),t[closedPromise_].promise.catch((()=>{}))))}function readableStreamReaderGenericRelease(t){const i=t[ownerReadableStream_];if(void 0===i)throw new TypeError("Reader is in an inconsistent state");"readable"===i[state_]||(t[closedPromise_]=createControlledPromise()),t[closedPromise_].reject(new TypeError),t[closedPromise_].promise.catch((()=>{})),i[reader_]=void 0,t[ownerReadableStream_]=void 0}function readableStreamBYOBReaderRead(t,i,a=!1){const n=t[ownerReadableStream_];return"errored"===n[state_]?Promise.reject(n[storedError_]):readableByteStreamControllerPullInto(n[readableStreamController_],i,a)}function readableStreamDefaultReaderRead(t,i=!1){const a=t[ownerReadableStream_];return"closed"===a[state_]?Promise.resolve(readableStreamCreateReadResult(void 0,!0,i)):"errored"===a[state_]?Promise.reject(a[storedError_]):a[readableStreamController_][pullSteps_](i)}function readableStreamFulfillReadIntoRequest(t,i,a){const n=t[reader_][readIntoRequests_].shift();n.resolve(readableStreamCreateReadResult(i,a,n.forAuthorCode))}function readableStreamFulfillReadRequest(t,i,a){const n=t[reader_][readRequests_].shift();n.resolve(readableStreamCreateReadResult(i,a,n.forAuthorCode))}function setUpReadableStreamDefaultController(t,i,a,n,o,s,l){i[controlledReadableStream_]=t,resetQueue(i),i[started_]=!1,i[closeRequested_]=!1,i[pullAgain_]=!1,i[pulling_]=!1,i[strategySizeAlgorithm_]=l,i[strategyHWM_]=s,i[pullAlgorithm_]=n,i[cancelAlgorithm_]=o,t[readableStreamController_]=i;const d=a();Promise.resolve(d).then((t=>{i[started_]=!0,readableStreamDefaultControllerCallPullIfNeeded(i)}),(t=>{readableStreamDefaultControllerError(i,t)}))}function isReadableStreamDefaultController(t){return"object"==typeof t&&null!==t&&controlledReadableStream_ in t}function readableStreamDefaultControllerHasBackpressure(t){return!readableStreamDefaultControllerShouldCallPull(t)}function readableStreamDefaultControllerCanCloseOrEnqueue(t){const i=t[controlledReadableStream_][state_];return!1===t[closeRequested_]&&"readable"===i}function readableStreamDefaultControllerGetDesiredSize(t){const i=t[controlledReadableStream_][state_];return"errored"===i?null:"closed"===i?0:t[strategyHWM_]-t[queueTotalSize_]}function readableStreamDefaultControllerClose(t){t[closeRequested_]=!0;const i=t[controlledReadableStream_];0===t[queue_].length&&(readableStreamDefaultControllerClearAlgorithms(t),readableStreamClose(i))}function readableStreamDefaultControllerEnqueue(t,i){const a=t[controlledReadableStream_];if(isReadableStreamLocked(a)&&readableStreamGetNumReadRequests(a)>0)readableStreamFulfillReadRequest(a,i,!1);else{let a;try{a=t[strategySizeAlgorithm_](i)}catch(n){throw readableStreamDefaultControllerError(t,n),n}try{enqueueValueWithSize(t,i,a)}catch(n){throw readableStreamDefaultControllerError(t,n),n}}readableStreamDefaultControllerCallPullIfNeeded(t)}function readableStreamDefaultControllerError(t,i){const a=t[controlledReadableStream_];"readable"===a[state_]&&(resetQueue(t),readableStreamDefaultControllerClearAlgorithms(t),readableStreamError(a,i))}function readableStreamDefaultControllerCallPullIfNeeded(t){if(readableStreamDefaultControllerShouldCallPull(t))if(t[pulling_])t[pullAgain_]=!0;else{if(t[pullAgain_])throw new RangeError("Stream controller is in an invalid state.");t[pulling_]=!0,t[pullAlgorithm_](t).then((i=>{t[pulling_]=!1,t[pullAgain_]&&(t[pullAgain_]=!1,readableStreamDefaultControllerCallPullIfNeeded(t))}),(i=>{readableStreamDefaultControllerError(t,i)}))}}function readableStreamDefaultControllerShouldCallPull(t){const i=t[controlledReadableStream_];if(!readableStreamDefaultControllerCanCloseOrEnqueue(t))return!1;if(!1===t[started_])return!1;if(isReadableStreamLocked(i)&&readableStreamGetNumReadRequests(i)>0)return!0;const a=readableStreamDefaultControllerGetDesiredSize(t);if(null===a)throw new RangeError("Stream is in an invalid state.");return a>0}function readableStreamDefaultControllerClearAlgorithms(t){t[pullAlgorithm_]=void 0,t[cancelAlgorithm_]=void 0,t[strategySizeAlgorithm_]=void 0}function setUpReadableByteStreamController(t,i,a,n,o,s,l){if(void 0!==t[readableStreamController_])throw new TypeError("Cannot reuse streams");if(void 0!==l&&(!isInteger(l)||l<=0))throw new RangeError("autoAllocateChunkSize must be a positive, finite integer");i[controlledReadableByteStream_]=t,i[pullAgain_]=!1,i[pulling_]=!1,readableByteStreamControllerClearPendingPullIntos(i),resetQueue(i),i[closeRequested_]=!1,i[started_]=!1,i[strategyHWM_]=validateAndNormalizeHighWaterMark(s),i[pullAlgorithm_]=n,i[cancelAlgorithm_]=o,i[autoAllocateChunkSize_]=l,i[pendingPullIntos_]=[],t[readableStreamController_]=i;const d=a();Promise.resolve(d).then((t=>{i[started_]=!0,readableByteStreamControllerCallPullIfNeeded(i)}),(t=>{readableByteStreamControllerError(i,t)}))}function isReadableStreamBYOBRequest(t){return"object"==typeof t&&null!==t&&associatedReadableByteStreamController_ in t}function isReadableByteStreamController(t){return"object"==typeof t&&null!==t&&controlledReadableByteStream_ in t}function readableByteStreamControllerCallPullIfNeeded(t){readableByteStreamControllerShouldCallPull(t)&&(t[pulling_]?t[pullAgain_]=!0:(t[pulling_]=!0,t[pullAlgorithm_](t).then((i=>{t[pulling_]=!1,t[pullAgain_]&&(t[pullAgain_]=!1,readableByteStreamControllerCallPullIfNeeded(t))}),(i=>{readableByteStreamControllerError(t,i)}))))}function readableByteStreamControllerClearAlgorithms(t){t[pullAlgorithm_]=void 0,t[cancelAlgorithm_]=void 0}function readableByteStreamControllerClearPendingPullIntos(t){readableByteStreamControllerInvalidateBYOBRequest(t),t[pendingPullIntos_]=[]}function readableByteStreamControllerClose(t){const i=t[controlledReadableByteStream_];if(t[queueTotalSize_]>0)t[closeRequested_]=!0;else{if(t[pendingPullIntos_].length>0){if(t[pendingPullIntos_][0].bytesFilled>0){const i=new TypeError;throw readableByteStreamControllerError(t,i),i}}readableByteStreamControllerClearAlgorithms(t),readableStreamClose(i)}}function readableByteStreamControllerCommitPullIntoDescriptor(t,i){let a=!1;"closed"===t[state_]&&(a=!0);const n=readableByteStreamControllerConvertPullIntoDescriptor(i);"default"===i.readerType?readableStreamFulfillReadRequest(t,n,a):readableStreamFulfillReadIntoRequest(t,n,a)}function readableByteStreamControllerConvertPullIntoDescriptor(t){const{bytesFilled:i,elementSize:a}=t;return new t.ctor(t.buffer,t.byteOffset,i/a)}function readableByteStreamControllerEnqueue(t,i){const a=t[controlledReadableByteStream_],{buffer:n,byteOffset:o,byteLength:s}=i,l=transferArrayBuffer(n);if(readableStreamHasDefaultReader(a))if(0===readableStreamGetNumReadRequests(a))readableByteStreamControllerEnqueueChunkToQueue(t,l,o,s);else{readableStreamFulfillReadRequest(a,new Uint8Array(l,o,s),!1)}else readableStreamHasBYOBReader(a)?(readableByteStreamControllerEnqueueChunkToQueue(t,l,o,s),readableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(t)):readableByteStreamControllerEnqueueChunkToQueue(t,l,o,s);readableByteStreamControllerCallPullIfNeeded(t)}function readableByteStreamControllerEnqueueChunkToQueue(t,i,a,n){t[queue_].push({buffer:i,byteOffset:a,byteLength:n}),t[queueTotalSize_]+=n}function readableByteStreamControllerError(t,i){const a=t[controlledReadableByteStream_];"readable"===a[state_]&&(readableByteStreamControllerClearPendingPullIntos(t),resetQueue(t),readableByteStreamControllerClearAlgorithms(t),readableStreamError(a,i))}function readableByteStreamControllerFillHeadPullIntoDescriptor(t,i,a){readableByteStreamControllerInvalidateBYOBRequest(t),a.bytesFilled+=i}function readableByteStreamControllerFillPullIntoDescriptorFromQueue(t,i){const a=i.elementSize,n=i.bytesFilled-i.bytesFilled%a,o=Math.min(t[queueTotalSize_],i.byteLength-i.bytesFilled),s=i.bytesFilled+o,l=s-s%a;let d=o,h=!1;l>n&&(d=l-i.bytesFilled,h=!0);const _=t[queue_];for(;d>0;){const a=_.front(),n=Math.min(d,a.byteLength),o=i.byteOffset+i.bytesFilled;copyDataBlockBytes(i.buffer,o,a.buffer,a.byteOffset,n),a.byteLength===n?_.shift():(a.byteOffset+=n,a.byteLength-=n),t[queueTotalSize_]-=n,readableByteStreamControllerFillHeadPullIntoDescriptor(t,n,i),d-=n}return h}function readableByteStreamControllerGetDesiredSize(t){const i=t[controlledReadableByteStream_][state_];return"errored"===i?null:"closed"===i?0:t[strategyHWM_]-t[queueTotalSize_]}function readableByteStreamControllerHandleQueueDrain(t){0===t[queueTotalSize_]&&t[closeRequested_]?(readableByteStreamControllerClearAlgorithms(t),readableStreamClose(t[controlledReadableByteStream_])):readableByteStreamControllerCallPullIfNeeded(t)}function readableByteStreamControllerInvalidateBYOBRequest(t){const i=t[byobRequest_];void 0!==i&&(i[associatedReadableByteStreamController_]=void 0,i[view_]=void 0,t[byobRequest_]=void 0)}function readableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(t){const i=t[pendingPullIntos_];for(;i.length>0;){if(0===t[queueTotalSize_])return;const a=i[0];readableByteStreamControllerFillPullIntoDescriptorFromQueue(t,a)&&(readableByteStreamControllerShiftPendingPullInto(t),readableByteStreamControllerCommitPullIntoDescriptor(t[controlledReadableByteStream_],a))}}function readableByteStreamControllerPullInto(t,i,a){const n=t[controlledReadableByteStream_],o=i.BYTES_PER_ELEMENT||1,s=i.constructor,l=i.byteOffset,d=i.byteLength,h={buffer:transferArrayBuffer(i.buffer),byteOffset:l,byteLength:d,bytesFilled:0,elementSize:o,ctor:s,readerType:"byob"};if(t[pendingPullIntos_].length>0)return t[pendingPullIntos_].push(h),readableStreamAddReadIntoRequest(n,a);if("closed"===n[state_]){const t=new s(h.buffer,h.byteOffset,0);return Promise.resolve(readableStreamCreateReadResult(t,!0,a))}if(t[queueTotalSize_]>0){if(readableByteStreamControllerFillPullIntoDescriptorFromQueue(t,h)){const i=readableByteStreamControllerConvertPullIntoDescriptor(h);return readableByteStreamControllerHandleQueueDrain(t),Promise.resolve(readableStreamCreateReadResult(i,!1,a))}if(t[closeRequested_]){const i=new TypeError;return readableByteStreamControllerError(t,i),Promise.reject(i)}}t[pendingPullIntos_].push(h);const _=readableStreamAddReadIntoRequest(n,a);return readableByteStreamControllerCallPullIfNeeded(t),_}function readableByteStreamControllerRespond(t,i){if(!isFiniteNonNegativeNumber(i=Number(i)))throw new RangeError("bytesWritten must be a finite, non-negative number");readableByteStreamControllerRespondInternal(t,i)}function readableByteStreamControllerRespondInClosedState(t,i){i.buffer=transferArrayBuffer(i.buffer);const a=t[controlledReadableByteStream_];if(readableStreamHasBYOBReader(a))for(;readableStreamGetNumReadIntoRequests(a)>0;){readableByteStreamControllerCommitPullIntoDescriptor(a,readableByteStreamControllerShiftPendingPullInto(t))}}function readableByteStreamControllerRespondInReadableState(t,i,a){if(a.bytesFilled+i>a.byteLength)throw new RangeError;if(readableByteStreamControllerFillHeadPullIntoDescriptor(t,i,a),a.bytesFilled<a.elementSize)return;readableByteStreamControllerShiftPendingPullInto(t);const n=a.bytesFilled%a.elementSize;if(n>0){const i=a.byteOffset+a.bytesFilled,o=cloneArrayBuffer(a.buffer,i-n,n);readableByteStreamControllerEnqueueChunkToQueue(t,o,0,o.byteLength)}a.buffer=transferArrayBuffer(a.buffer),a.bytesFilled=a.bytesFilled-n,readableByteStreamControllerCommitPullIntoDescriptor(t[controlledReadableByteStream_],a),readableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(t)}function readableByteStreamControllerRespondInternal(t,i){const a=t[pendingPullIntos_][0];if("closed"===t[controlledReadableByteStream_][state_]){if(0!==i)throw new TypeError;readableByteStreamControllerRespondInClosedState(t,a)}else readableByteStreamControllerRespondInReadableState(t,i,a);readableByteStreamControllerCallPullIfNeeded(t)}function readableByteStreamControllerRespondWithNewView(t,i){const a=t[pendingPullIntos_][0];if(a.byteOffset+a.bytesFilled!==i.byteOffset)throw new RangeError;if(a.byteLength!==i.byteLength)throw new RangeError;a.buffer=i.buffer,readableByteStreamControllerRespondInternal(t,i.byteLength)}function readableByteStreamControllerShiftPendingPullInto(t){const i=t[pendingPullIntos_].shift();return readableByteStreamControllerInvalidateBYOBRequest(t),i}function readableByteStreamControllerShouldCallPull(t){const i=t[controlledReadableByteStream_];if("readable"!==i[state_])return!1;if(t[closeRequested_])return!1;if(!t[started_])return!1;if(readableStreamHasDefaultReader(i)&&readableStreamGetNumReadRequests(i)>0)return!0;if(readableStreamHasBYOBReader(i)&&readableStreamGetNumReadIntoRequests(i)>0)return!0;return readableByteStreamControllerGetDesiredSize(t)>0}function setUpReadableStreamBYOBRequest(t,i,a){if(!isReadableByteStreamController(i))throw new TypeError;if(!ArrayBuffer.isView(a))throw new TypeError;t[associatedReadableByteStreamController_]=i,t[view_]=a}const backpressure_=Symbol("backpressure_"),closeRequest_=Symbol("closeRequest_"),inFlightWriteRequest_=Symbol("inFlightWriteRequest_"),inFlightCloseRequest_=Symbol("inFlightCloseRequest_"),pendingAbortRequest_=Symbol("pendingAbortRequest_"),writableStreamController_=Symbol("writableStreamController_"),writer_=Symbol("writer_"),writeRequests_=Symbol("writeRequests_"),abortAlgorithm_=Symbol("abortAlgorithm_"),closeAlgorithm_=Symbol("closeAlgorithm_"),controlledWritableStream_=Symbol("controlledWritableStream_"),started_$1=Symbol("started_"),strategyHWM_$1=Symbol("strategyHWM_"),strategySizeAlgorithm_$1=Symbol("strategySizeAlgorithm_"),writeAlgorithm_=Symbol("writeAlgorithm_"),ownerWritableStream_=Symbol("ownerWritableStream_"),closedPromise_$1=Symbol("closedPromise_"),readyPromise_=Symbol("readyPromise_"),errorSteps_=Symbol("errorSteps_"),abortSteps_=Symbol("abortSteps_");function initializeWritableStream(t){t[state_]="writable",t[storedError_]=void 0,t[writer_]=void 0,t[writableStreamController_]=void 0,t[inFlightWriteRequest_]=void 0,t[closeRequest_]=void 0,t[inFlightCloseRequest_]=void 0,t[pendingAbortRequest_]=void 0,t[writeRequests_]=[],t[backpressure_]=!1}function isWritableStream(t){return"object"==typeof t&&null!==t&&writableStreamController_ in t}function isWritableStreamLocked(t){return void 0!==t[writer_]}function writableStreamAbort(t,i){const a=t[state_];if("closed"===a||"errored"===a)return Promise.resolve(void 0);let n=t[pendingAbortRequest_];if(void 0!==n)return n.promise;let o=!1;"erroring"===a&&(o=!0,i=void 0),n={reason:i,wasAlreadyErroring:o};const s=new Promise(((t,i)=>{n.resolve=t,n.reject=i}));return n.promise=s,t[pendingAbortRequest_]=n,o||writableStreamStartErroring(t,i),s}function writableStreamAddWriteRequest(t){const i=createControlledPromise();return t[writeRequests_].push(i),i.promise}function writableStreamDealWithRejection(t,i){"writable"!==t[state_]?writableStreamFinishErroring(t):writableStreamStartErroring(t,i)}function writableStreamStartErroring(t,i){const a=t[writableStreamController_];t[state_]="erroring",t[storedError_]=i;const n=t[writer_];void 0!==n&&writableStreamDefaultWriterEnsureReadyPromiseRejected(n,i),!writableStreamHasOperationMarkedInFlight(t)&&a[started_$1]&&writableStreamFinishErroring(t)}function writableStreamFinishErroring(t){t[state_]="errored";const i=t[writableStreamController_];i[errorSteps_]();const a=t[storedError_];for(const o of t[writeRequests_])o.reject(a);t[writeRequests_]=[];const n=t[pendingAbortRequest_];if(void 0===n)return void writableStreamRejectCloseAndClosedPromiseIfNeeded(t);if(t[pendingAbortRequest_]=void 0,n.wasAlreadyErroring)return n.reject(a),void writableStreamRejectCloseAndClosedPromiseIfNeeded(t);i[abortSteps_](n.reason).then((i=>{n.resolve(),writableStreamRejectCloseAndClosedPromiseIfNeeded(t)}),(i=>{n.reject(i),writableStreamRejectCloseAndClosedPromiseIfNeeded(t)}))}function writableStreamFinishInFlightWrite(t){t[inFlightWriteRequest_].resolve(void 0),t[inFlightWriteRequest_]=void 0}function writableStreamFinishInFlightWriteWithError(t,i){t[inFlightWriteRequest_].reject(i),t[inFlightWriteRequest_]=void 0,writableStreamDealWithRejection(t,i)}function writableStreamFinishInFlightClose(t){t[inFlightCloseRequest_].resolve(void 0),t[inFlightCloseRequest_]=void 0;"erroring"===t[state_]&&(t[storedError_]=void 0,void 0!==t[pendingAbortRequest_]&&(t[pendingAbortRequest_].resolve(),t[pendingAbortRequest_]=void 0)),t[state_]="closed";const i=t[writer_];void 0!==i&&i[closedPromise_$1].resolve(void 0)}function writableStreamFinishInFlightCloseWithError(t,i){t[inFlightCloseRequest_].reject(i),t[inFlightCloseRequest_]=void 0,void 0!==t[pendingAbortRequest_]&&(t[pendingAbortRequest_].reject(i),t[pendingAbortRequest_]=void 0),writableStreamDealWithRejection(t,i)}function writableStreamCloseQueuedOrInFlight(t){return void 0!==t[closeRequest_]||void 0!==t[inFlightCloseRequest_]}function writableStreamHasOperationMarkedInFlight(t){return void 0!==t[inFlightWriteRequest_]||void 0!==t[inFlightCloseRequest_]}function writableStreamMarkCloseRequestInFlight(t){t[inFlightCloseRequest_]=t[closeRequest_],t[closeRequest_]=void 0}function writableStreamMarkFirstWriteRequestInFlight(t){const i=t[writeRequests_].shift();t[inFlightWriteRequest_]=i}function writableStreamRejectCloseAndClosedPromiseIfNeeded(t){const i=t[closeRequest_];void 0!==i&&(i.reject(t[storedError_]),t[closeRequest_]=void 0);const a=t[writer_];void 0!==a&&(a[closedPromise_$1].reject(t[storedError_]),a[closedPromise_$1].promise.catch((()=>{})))}function writableStreamUpdateBackpressure(t,i){const a=t[writer_];void 0!==a&&i!==t[backpressure_]&&(i?a[readyPromise_]=createControlledPromise():a[readyPromise_].resolve(void 0)),t[backpressure_]=i}function isWritableStreamDefaultWriter(t){return"object"==typeof t&&null!==t&&ownerWritableStream_ in t}function writableStreamDefaultWriterAbort(t,i){return writableStreamAbort(t[ownerWritableStream_],i)}function writableStreamDefaultWriterClose(t){const i=t[ownerWritableStream_],a=i[state_];if("closed"===a||"errored"===a)return Promise.reject(new TypeError("Writer stream is already closed or errored"));const n=createControlledPromise();return i[closeRequest_]=n,i[backpressure_]&&"writable"===a&&t[readyPromise_].resolve(void 0),writableStreamDefaultControllerClose(i[writableStreamController_]),n.promise}function writableStreamDefaultWriterCloseWithErrorPropagation(t){const i=t[ownerWritableStream_],a=i[state_];return writableStreamCloseQueuedOrInFlight(i)||"closed"===a?Promise.resolve(void 0):"errored"===a?Promise.reject(i[storedError_]):writableStreamDefaultWriterClose(t)}function writableStreamDefaultWriterEnsureClosedPromiseRejected(t,i){const a=t[closedPromise_$1];0===a.state?a.reject(i):(t[closedPromise_$1]=createControlledPromise(),t[closedPromise_$1].reject(i)),t[closedPromise_$1].promise.catch((()=>{}))}function writableStreamDefaultWriterEnsureReadyPromiseRejected(t,i){const a=t[readyPromise_];0===a.state?a.reject(i):(t[readyPromise_]=createControlledPromise(),t[readyPromise_].reject(i)),t[readyPromise_].promise.catch((()=>{}))}function writableStreamDefaultWriterGetDesiredSize(t){const i=t[ownerWritableStream_],a=i[state_];return"errored"===a||"erroring"===a?null:"closed"===a?0:writableStreamDefaultControllerGetDesiredSize(i[writableStreamController_])}function writableStreamDefaultWriterRelease(t){const i=t[ownerWritableStream_],a=new TypeError;writableStreamDefaultWriterEnsureReadyPromiseRejected(t,a),writableStreamDefaultWriterEnsureClosedPromiseRejected(t,a),i[writer_]=void 0,t[ownerWritableStream_]=void 0}function writableStreamDefaultWriterWrite(t,i){const a=t[ownerWritableStream_],n=a[writableStreamController_],o=writableStreamDefaultControllerGetChunkSize(n,i);if(t[ownerWritableStream_]!==a)return Promise.reject(new TypeError);const s=a[state_];if("errored"===s)return Promise.reject(a[storedError_]);if(writableStreamCloseQueuedOrInFlight(a)||"closed"===s)return Promise.reject(new TypeError("Cannot write to a closing or closed stream"));if("erroring"===s)return Promise.reject(a[storedError_]);const l=writableStreamAddWriteRequest(a);return writableStreamDefaultControllerWrite(n,i,o),l}function setUpWritableStreamDefaultController(t,i,a,n,o,s,l,d){if(!isWritableStream(t))throw new TypeError;if(void 0!==t[writableStreamController_])throw new TypeError;i[controlledWritableStream_]=t,t[writableStreamController_]=i,resetQueue(i),i[started_$1]=!1,i[strategySizeAlgorithm_$1]=d,i[strategyHWM_$1]=l,i[writeAlgorithm_]=n,i[closeAlgorithm_]=o,i[abortAlgorithm_]=s;const h=writableStreamDefaultControllerGetBackpressure(i);writableStreamUpdateBackpressure(t,h);const _=a();Promise.resolve(_).then((t=>{i[started_$1]=!0,writableStreamDefaultControllerAdvanceQueueIfNeeded(i)}),(a=>{i[started_$1]=!0,writableStreamDealWithRejection(t,a)}))}function isWritableStreamDefaultController(t){return"object"==typeof t&&null!==t&&controlledWritableStream_ in t}function writableStreamDefaultControllerClearAlgorithms(t){t[writeAlgorithm_]=void 0,t[closeAlgorithm_]=void 0,t[abortAlgorithm_]=void 0,t[strategySizeAlgorithm_$1]=void 0}function writableStreamDefaultControllerClose(t){enqueueValueWithSize(t,"close",0),writableStreamDefaultControllerAdvanceQueueIfNeeded(t)}function writableStreamDefaultControllerGetChunkSize(t,i){let a;try{a=t[strategySizeAlgorithm_$1](i)}catch(n){writableStreamDefaultControllerErrorIfNeeded(t,n),a=1}return a}function writableStreamDefaultControllerGetDesiredSize(t){return t[strategyHWM_$1]-t[queueTotalSize_]}function writableStreamDefaultControllerWrite(t,i,a){try{enqueueValueWithSize(t,{chunk:i},a)}catch(o){return void writableStreamDefaultControllerErrorIfNeeded(t,o)}const n=t[controlledWritableStream_];if(!writableStreamCloseQueuedOrInFlight(n)&&"writable"===n[state_]){writableStreamUpdateBackpressure(n,writableStreamDefaultControllerGetBackpressure(t))}writableStreamDefaultControllerAdvanceQueueIfNeeded(t)}function writableStreamDefaultControllerAdvanceQueueIfNeeded(t){if(!t[started_$1])return;const i=t[controlledWritableStream_];if(void 0!==i[inFlightWriteRequest_])return;const a=i[state_];if("closed"===a||"errored"===a)return;if("erroring"===a)return void writableStreamFinishErroring(i);if(0===t[queue_].length)return;const n=peekQueueValue(t);"close"===n?writableStreamDefaultControllerProcessClose(t):writableStreamDefaultControllerProcessWrite(t,n.chunk)}function writableStreamDefaultControllerErrorIfNeeded(t,i){"writable"===t[controlledWritableStream_][state_]&&writableStreamDefaultControllerError(t,i)}function writableStreamDefaultControllerProcessClose(t){const i=t[controlledWritableStream_];writableStreamMarkCloseRequestInFlight(i),dequeueValue(t);const a=t[closeAlgorithm_]();writableStreamDefaultControllerClearAlgorithms(t),a.then((t=>{writableStreamFinishInFlightClose(i)}),(t=>{writableStreamFinishInFlightCloseWithError(i,t)}))}function writableStreamDefaultControllerProcessWrite(t,i){const a=t[controlledWritableStream_];writableStreamMarkFirstWriteRequestInFlight(a),t[writeAlgorithm_](i).then((i=>{writableStreamFinishInFlightWrite(a);const n=a[state_];if(dequeueValue(t),!writableStreamCloseQueuedOrInFlight(a)&&"writable"===n){const i=writableStreamDefaultControllerGetBackpressure(t);writableStreamUpdateBackpressure(a,i)}writableStreamDefaultControllerAdvanceQueueIfNeeded(t)}),(i=>{"writable"===a[state_]&&writableStreamDefaultControllerClearAlgorithms(t),writableStreamFinishInFlightWriteWithError(a,i)}))}function writableStreamDefaultControllerGetBackpressure(t){return writableStreamDefaultControllerGetDesiredSize(t)<=0}function writableStreamDefaultControllerError(t,i){const a=t[controlledWritableStream_];writableStreamDefaultControllerClearAlgorithms(t),writableStreamStartErroring(a,i)}class ReadableStreamDefaultReader{constructor(t){if(!isReadableStream(t))throw new TypeError;if(isReadableStreamLocked(t))throw new TypeError("The stream is locked.");readableStreamReaderGenericInitialize(this,t),this[readRequests_]=[]}get closed(){return isReadableStreamDefaultReader(this)?this[closedPromise_].promise:Promise.reject(new TypeError)}cancel(t){if(!isReadableStreamDefaultReader(this))return Promise.reject(new TypeError);const i=this[ownerReadableStream_];return void 0===i?Promise.reject(new TypeError("Reader is not associated with a stream")):readableStreamCancel(i,t)}read(){return isReadableStreamDefaultReader(this)?void 0===this[ownerReadableStream_]?Promise.reject(new TypeError("Reader is not associated with a stream")):readableStreamDefaultReaderRead(this,!0):Promise.reject(new TypeError)}releaseLock(){if(!isReadableStreamDefaultReader(this))throw new TypeError;if(void 0!==this[ownerReadableStream_]){if(0!==this[readRequests_].length)throw new TypeError("Cannot release a stream with pending read requests");readableStreamReaderGenericRelease(this)}}}class WritableStreamDefaultWriter{constructor(t){if(!isWritableStream(t))throw new TypeError;if(isWritableStreamLocked(t))throw new TypeError("Stream is already locked");this[ownerWritableStream_]=t,t[writer_]=this;const i=createControlledPromise(),a=createControlledPromise();this[readyPromise_]=i,this[closedPromise_$1]=a;const n=t[state_];if("writable"===n)!writableStreamCloseQueuedOrInFlight(t)&&t[backpressure_]||i.resolve(void 0);else if("erroring"===n)i.reject(t[storedError_]),i.promise.catch((()=>{}));else if("closed"===n)i.resolve(void 0),a.resolve(void 0);else{const n=t[storedError_];i.reject(n),i.promise.catch((()=>{})),a.reject(n),a.promise.catch((()=>{}))}}abort(t){return isWritableStreamDefaultWriter(this)?void 0===this[ownerWritableStream_]?Promise.reject(new TypeError("Writer is not connected to a stream")):writableStreamDefaultWriterAbort(this,t):Promise.reject(new TypeError)}close(){if(!isWritableStreamDefaultWriter(this))return Promise.reject(new TypeError);const t=this[ownerWritableStream_];return void 0===t?Promise.reject(new TypeError("Writer is not connected to a stream")):writableStreamCloseQueuedOrInFlight(t)?Promise.reject(new TypeError):writableStreamDefaultWriterClose(this)}releaseLock(){void 0!==this[ownerWritableStream_]&&writableStreamDefaultWriterRelease(this)}write(t){return isWritableStreamDefaultWriter(this)?void 0===this[ownerWritableStream_]?Promise.reject(new TypeError("Writer is not connected to a stream")):writableStreamDefaultWriterWrite(this,t):Promise.reject(new TypeError)}get closed(){return isWritableStreamDefaultWriter(this)?this[closedPromise_$1].promise:Promise.reject(new TypeError)}get desiredSize(){if(!isWritableStreamDefaultWriter(this))throw new TypeError;if(void 0===this[ownerWritableStream_])throw new TypeError("Writer is not connected to stream");return writableStreamDefaultWriterGetDesiredSize(this)}get ready(){return isWritableStreamDefaultWriter(this)?this[readyPromise_].promise:Promise.reject(new TypeError)}}function pipeTo(t,i,a){const n=!!a.preventClose,o=!!a.preventAbort,s=!!a.preventCancel,l=a.signal;let d=!1,h=Promise.resolve();const _=createControlledPromise(),f=new ReadableStreamDefaultReader(t),m=new WritableStreamDefaultWriter(i);let b;function onStreamErrored(t,i,a){"errored"===t[state_]?a(t[storedError_]):i.catch(a)}if(void 0!==l&&(b=()=>{const a=new DOMException("Aborted","AbortError"),n=[];!1===o&&n.push((()=>"writable"===i[state_]?writableStreamAbort(i,a):Promise.resolve())),!1===s&&n.push((()=>"readable"===t[state_]?readableStreamCancel(t,a):Promise.resolve())),shutDown((()=>Promise.all(n.map((t=>t()))).then((t=>{}))),{actualError:a})},!0===l.aborted?b():l.addEventListener("abort",b)),onStreamErrored(t,f[closedPromise_].promise,(t=>{shutDown(o?void 0:()=>writableStreamAbort(i,t),{actualError:t})})),onStreamErrored(i,m[closedPromise_$1].promise,(i=>{shutDown(s?void 0:()=>readableStreamCancel(t,i),{actualError:i})})),function onStreamClosed(t,i,a){"closed"===t[state_]?a():i.then(a)}(t,f[closedPromise_].promise,(()=>{n?shutDown():shutDown((()=>writableStreamDefaultWriterCloseWithErrorPropagation(m)))})),writableStreamCloseQueuedOrInFlight(i)||"closed"===i[state_]){const i=new TypeError;shutDown(s?void 0:()=>readableStreamCancel(t,i),{actualError:i})}function awaitLatestWrite(){const t=h;return h.then((()=>t===h?void 0:awaitLatestWrite()))}function flushRemainder(){return"writable"!==i[state_]||writableStreamCloseQueuedOrInFlight(i)?void 0:awaitLatestWrite()}function shutDown(t,i){if(d)return;function finishShutDown(){t().then((t=>finalize(i)),(t=>finalize({actualError:t})))}d=!0,void 0===t&&(t=()=>Promise.resolve());const a=flushRemainder();a?a.then(finishShutDown):finishShutDown()}function finalize(t){writableStreamDefaultWriterRelease(m),readableStreamReaderGenericRelease(f),l&&b&&l.removeEventListener("abort",b),t?_.reject(t.actualError):_.resolve(void 0)}return function next(){d||m[readyPromise_].promise.then((()=>{readableStreamDefaultReaderRead(f).then((({value:t,done:i})=>{i||(h=writableStreamDefaultWriterWrite(m,t).catch((()=>{})),next())}),(t=>{h=Promise.resolve()}))}))}(),_.promise}class ReadableStreamDefaultController{constructor(){throw new TypeError}get desiredSize(){return readableStreamDefaultControllerGetDesiredSize(this)}close(){if(!isReadableStreamDefaultController(this))throw new TypeError;if(!readableStreamDefaultControllerCanCloseOrEnqueue(this))throw new TypeError("Cannot close, the stream is already closing or not readable");readableStreamDefaultControllerClose(this)}enqueue(t){if(!isReadableStreamDefaultController(this))throw new TypeError;if(!readableStreamDefaultControllerCanCloseOrEnqueue(this))throw new TypeError("Cannot enqueue, the stream is closing or not readable");readableStreamDefaultControllerEnqueue(this,t)}error(t){if(!isReadableStreamDefaultController(this))throw new TypeError;readableStreamDefaultControllerError(this,t)}[cancelSteps_](t){resetQueue(this);const i=this[cancelAlgorithm_](t);return readableStreamDefaultControllerClearAlgorithms(this),i}[pullSteps_](t){const i=this[controlledReadableStream_];if(this[queue_].length>0){const a=dequeueValue(this);return this[closeRequested_]&&0===this[queue_].length?(readableStreamDefaultControllerClearAlgorithms(this),readableStreamClose(i)):readableStreamDefaultControllerCallPullIfNeeded(this),Promise.resolve(readableStreamCreateReadResult(a,!1,t))}const a=readableStreamAddReadRequest(i,t);return readableStreamDefaultControllerCallPullIfNeeded(this),a}}function setUpReadableStreamDefaultControllerFromUnderlyingSource(t,i,a,n){const o=Object.create(ReadableStreamDefaultController.prototype),s=createAlgorithmFromUnderlyingMethod(i,"pull",[o]),l=createAlgorithmFromUnderlyingMethod(i,"cancel",[]);setUpReadableStreamDefaultController(t,o,(()=>invokeOrNoop(i,"start",[o])),s,l,a,n)}class ReadableStreamBYOBRequest{constructor(){throw new TypeError}get view(){if(!isReadableStreamBYOBRequest(this))throw new TypeError;return this[view_]}respond(t){if(!isReadableStreamBYOBRequest(this))throw new TypeError;if(void 0===this[associatedReadableByteStreamController_])throw new TypeError;return readableByteStreamControllerRespond(this[associatedReadableByteStreamController_],t)}respondWithNewView(t){if(!isReadableStreamBYOBRequest(this))throw new TypeError;if(void 0===this[associatedReadableByteStreamController_])throw new TypeError;if(!ArrayBuffer.isView(t))throw new TypeError("view parameter must be a TypedArray");return readableByteStreamControllerRespondWithNewView(this[associatedReadableByteStreamController_],t)}}class ReadableByteStreamController{constructor(){throw new TypeError}get byobRequest(){if(!isReadableByteStreamController(this))throw new TypeError;if(void 0===this[byobRequest_]&&this[pendingPullIntos_].length>0){const t=this[pendingPullIntos_][0],i=new Uint8Array(t.buffer,t.byteOffset+t.bytesFilled,t.byteLength-t.bytesFilled),a=Object.create(ReadableStreamBYOBRequest.prototype);setUpReadableStreamBYOBRequest(a,this,i),this[byobRequest_]=a}return this[byobRequest_]}get desiredSize(){if(!isReadableByteStreamController(this))throw new TypeError;return readableByteStreamControllerGetDesiredSize(this)}close(){if(!isReadableByteStreamController(this))throw new TypeError;if(this[closeRequested_])throw new TypeError("Stream is already closing");if("readable"!==this[controlledReadableByteStream_][state_])throw new TypeError("Stream is closed or errored");readableByteStreamControllerClose(this)}enqueue(t){if(!isReadableByteStreamController(this))throw new TypeError;if(this[closeRequested_])throw new TypeError("Stream is already closing");if("readable"!==this[controlledReadableByteStream_][state_])throw new TypeError("Stream is closed or errored");if(!ArrayBuffer.isView(t))throw new TypeError("chunk must be a valid ArrayBufferView");return readableByteStreamControllerEnqueue(this,t)}error(t){if(!isReadableByteStreamController(this))throw new TypeError;readableByteStreamControllerError(this,t)}[cancelSteps_](t){if(this[pendingPullIntos_].length>0){this[pendingPullIntos_][0].bytesFilled=0}resetQueue(this);const i=this[cancelAlgorithm_](t);return readableByteStreamControllerClearAlgorithms(this),i}[pullSteps_](t){const i=this[controlledReadableByteStream_];if(this[queueTotalSize_]>0){const i=this[queue_].shift();this[queueTotalSize_]-=i.byteLength,readableByteStreamControllerHandleQueueDrain(this);const a=new Uint8Array(i.buffer,i.byteOffset,i.byteLength);return Promise.resolve(readableStreamCreateReadResult(a,!1,t))}const a=this[autoAllocateChunkSize_];if(void 0!==a){let t;try{t=new ArrayBuffer(a)}catch(o){return Promise.reject(o)}const i={buffer:t,byteOffset:0,byteLength:a,bytesFilled:0,elementSize:1,ctor:Uint8Array,readerType:"default"};this[pendingPullIntos_].push(i)}const n=readableStreamAddReadRequest(i,t);return readableByteStreamControllerCallPullIfNeeded(this),n}}function setUpReadableByteStreamControllerFromUnderlyingSource(t,i,a){const n=Object.create(ReadableByteStreamController.prototype),o=createAlgorithmFromUnderlyingMethod(i,"pull",[n]),s=createAlgorithmFromUnderlyingMethod(i,"cancel",[]);let l=i.autoAllocateChunkSize;if(void 0!==l&&(l=Number(l),!isInteger(l)||l<=0))throw new RangeError("autoAllocateChunkSize must be a positive, finite integer");setUpReadableByteStreamController(t,n,(()=>invokeOrNoop(i,"start",[n])),o,s,a,l)}class SDReadableStreamBYOBReader{constructor(t){if(!isReadableStream(t))throw new TypeError;if(!isReadableByteStreamController(t[readableStreamController_]))throw new TypeError;if(isReadableStreamLocked(t))throw new TypeError("The stream is locked.");readableStreamReaderGenericInitialize(this,t),this[readIntoRequests_]=[]}get closed(){return isReadableStreamBYOBReader(this)?this[closedPromise_].promise:Promise.reject(new TypeError)}cancel(t){if(!isReadableStreamBYOBReader(this))return Promise.reject(new TypeError);const i=this[ownerReadableStream_];return void 0===i?Promise.reject(new TypeError("Reader is not associated with a stream")):readableStreamCancel(i,t)}read(t){return isReadableStreamBYOBReader(this)?void 0===this[ownerReadableStream_]?Promise.reject(new TypeError("Reader is not associated with a stream")):ArrayBuffer.isView(t)?0===t.byteLength?Promise.reject(new TypeError("supplied buffer view must be > 0 bytes")):readableStreamBYOBReaderRead(this,t,!0):Promise.reject(new TypeError("view argument must be a valid ArrayBufferView")):Promise.reject(new TypeError)}releaseLock(){if(!isReadableStreamBYOBReader(this))throw new TypeError;if(void 0===this[ownerReadableStream_])throw new TypeError("Reader is not associated with a stream");if(this[readIntoRequests_].length>0)throw new TypeError;readableStreamReaderGenericRelease(this)}}class SDReadableStream{constructor(t={},i={}){initializeReadableStream(this);const a=i.size,n=i.highWaterMark,o=t.type;if(void 0===o){const i=makeSizeAlgorithmFromSizeFunction(a);setUpReadableStreamDefaultControllerFromUnderlyingSource(this,t,validateAndNormalizeHighWaterMark(void 0===n?1:n),i)}else{if("bytes"!==String(o))throw new RangeError("The underlying source's `type` field must be undefined or 'bytes'");if(void 0!==a)throw new RangeError("bytes streams cannot have a strategy with a `size` field");setUpReadableByteStreamControllerFromUnderlyingSource(this,t,validateAndNormalizeHighWaterMark(void 0===n?0:n))}}get locked(){return isReadableStreamLocked(this)}getReader(t){if(!isReadableStream(this))throw new TypeError;void 0===t&&(t={});const{mode:i}=t;if(void 0===i)return new ReadableStreamDefaultReader(this);if("byob"===String(i))return new SDReadableStreamBYOBReader(this);throw RangeError("mode option must be undefined or `byob`")}cancel(t){return isReadableStream(this)?isReadableStreamLocked(this)?Promise.reject(new TypeError("Cannot cancel a locked stream")):readableStreamCancel(this,t):Promise.reject(new TypeError)}tee(){return readableStreamTee(this,!1)}pipeThrough(t,i={}){const{readable:a,writable:n}=t;if(!isReadableStream(this))throw new TypeError;if(!isWritableStream(n))throw new TypeError("writable must be a WritableStream");if(!isReadableStream(a))throw new TypeError("readable must be a ReadableStream");if(void 0!==i.signal&&!isAbortSignal(i.signal))throw new TypeError("options.signal must be an AbortSignal instance");if(isReadableStreamLocked(this))throw new TypeError("Cannot pipeThrough on a locked stream");if(isWritableStreamLocked(n))throw new TypeError("Cannot pipeThrough to a locked stream");return pipeTo(this,n,i).catch((()=>{})),a}pipeTo(t,i={}){return isReadableStream(this)?isWritableStream(t)?void 0===i.signal||isAbortSignal(i.signal)?isReadableStreamLocked(this)?Promise.reject(new TypeError("Cannot pipe from a locked stream")):isWritableStreamLocked(t)?Promise.reject(new TypeError("Cannot pipe to a locked stream")):pipeTo(this,t,i):Promise.reject(new TypeError("options.signal must be an AbortSignal instance")):Promise.reject(new TypeError("destination must be a WritableStream")):Promise.reject(new TypeError)}}function createReadableStream(t,i,a,n,o){void 0===n&&(n=1),void 0===o&&(o=()=>1);const s=Object.create(SDReadableStream.prototype);initializeReadableStream(s);return setUpReadableStreamDefaultController(s,Object.create(ReadableStreamDefaultController.prototype),t,i,a,n,o),s}function readableStreamTee(t,i){if(!isReadableStream(t))throw new TypeError;const a=new ReadableStreamDefaultReader(t);let n,o,s,l,d,h=!1,_=!1,f=!1;const m=new Promise((t=>d=t)),pullAlgorithm=()=>readableStreamDefaultReaderRead(a).then((({value:t,done:a})=>{if(a&&!h&&(_||readableStreamDefaultControllerClose(s[readableStreamController_]),f||readableStreamDefaultControllerClose(l[readableStreamController_]),h=!0),h)return;const n=t;let o=t;_||readableStreamDefaultControllerEnqueue(s[readableStreamController_],n),f||(i&&(o=cloneValue(o)),readableStreamDefaultControllerEnqueue(l[readableStreamController_],o))})),startAlgorithm=()=>{};return s=createReadableStream(startAlgorithm,pullAlgorithm,(i=>{if(_=!0,n=i,f){const i=readableStreamCancel(t,[n,o]);d(i)}return m})),l=createReadableStream(startAlgorithm,pullAlgorithm,(i=>{if(f=!0,o=i,_){const i=readableStreamCancel(t,[n,o]);d(i)}return m})),a[closedPromise_].promise.catch((t=>{h||(readableStreamDefaultControllerError(s[readableStreamController_],t),readableStreamDefaultControllerError(l[readableStreamController_],t),h=!0)})),[s,l]}class WritableStreamDefaultController{constructor(){throw new TypeError}error(t){if(!isWritableStreamDefaultController(this))throw new TypeError;"writable"===this[controlledWritableStream_][state_]&&writableStreamDefaultControllerError(this,t)}[abortSteps_](t){const i=this[abortAlgorithm_](t);return writableStreamDefaultControllerClearAlgorithms(this),i}[errorSteps_](){resetQueue(this)}}function setUpWritableStreamDefaultControllerFromUnderlyingSink(t,i,a,n){const o=Object.create(WritableStreamDefaultController.prototype),s=createAlgorithmFromUnderlyingMethod(i,"write",[o]),l=createAlgorithmFromUnderlyingMethod(i,"close",[]),d=createAlgorithmFromUnderlyingMethod(i,"abort",[]);setUpWritableStreamDefaultController(t,o,(function(){return invokeOrNoop(i,"start",[o])}),s,l,d,a,n)}class WritableStream{constructor(t={},i={}){initializeWritableStream(this);const a=i.size,n=i.highWaterMark;if(void 0!==t.type)throw new RangeError("The type of an underlying sink must be undefined");const o=makeSizeAlgorithmFromSizeFunction(a);setUpWritableStreamDefaultControllerFromUnderlyingSink(this,t,validateAndNormalizeHighWaterMark(void 0===n?1:n),o)}get locked(){if(!isWritableStream(this))throw new TypeError;return isWritableStreamLocked(this)}abort(t){return isWritableStream(this)?isWritableStreamLocked(this)?Promise.reject(new TypeError("Cannot abort a locked stream")):writableStreamAbort(this,t):Promise.reject(new TypeError)}getWriter(){if(!isWritableStream(this))throw new TypeError;return new WritableStreamDefaultWriter(this)}}function createWritableStream(t,i,a,n,o,s){void 0===o&&(o=1),void 0===s&&(s=()=>1);const l=Object.create(WritableStream.prototype);initializeWritableStream(l);return setUpWritableStreamDefaultController(l,Object.create(WritableStreamDefaultController.prototype),t,i,a,n,o,s),l}const backpressure_$1=Symbol("backpressure_"),backpressureChangePromise_=Symbol("backpressureChangePromise_"),readable_=Symbol("readable_"),transformStreamController_=Symbol("transformStreamController_"),writable_=Symbol("writable_"),controlledTransformStream_=Symbol("controlledTransformStream_"),flushAlgorithm_=Symbol("flushAlgorithm_"),transformAlgorithm_=Symbol("transformAlgorithm_");function isTransformStream(t){return"object"==typeof t&&null!==t&&transformStreamController_ in t}function initializeTransformStream(t,i,a,n,o,s){const startAlgorithm=function(){return i};t[writable_]=createWritableStream(startAlgorithm,(function(i){return transformStreamDefaultSinkWriteAlgorithm(t,i)}),(function(){return transformStreamDefaultSinkCloseAlgorithm(t)}),(function(i){return transformStreamDefaultSinkAbortAlgorithm(t,i)}),a,n);t[readable_]=createReadableStream(startAlgorithm,(function(){return transformStreamDefaultSourcePullAlgorithm(t)}),(function(i){return transformStreamErrorWritableAndUnblockWrite(t,i),Promise.resolve(void 0)}),o,s),t[backpressure_$1]=void 0,t[backpressureChangePromise_]=void 0,transformStreamSetBackpressure(t,!0),t[transformStreamController_]=void 0}function transformStreamError(t,i){readableStreamDefaultControllerError(t[readable_][readableStreamController_],i),transformStreamErrorWritableAndUnblockWrite(t,i)}function transformStreamErrorWritableAndUnblockWrite(t,i){transformStreamDefaultControllerClearAlgorithms(t[transformStreamController_]),writableStreamDefaultControllerErrorIfNeeded(t[writable_][writableStreamController_],i),t[backpressure_$1]&&transformStreamSetBackpressure(t,!1)}function transformStreamSetBackpressure(t,i){void 0!==t[backpressure_$1]&&t[backpressureChangePromise_].resolve(void 0),t[backpressureChangePromise_]=createControlledPromise(),t[backpressure_$1]=i}function isTransformStreamDefaultController(t){return"object"==typeof t&&null!==t&&controlledTransformStream_ in t}function setUpTransformStreamDefaultController(t,i,a,n){i[controlledTransformStream_]=t,t[transformStreamController_]=i,i[transformAlgorithm_]=a,i[flushAlgorithm_]=n}function transformStreamDefaultControllerClearAlgorithms(t){t[transformAlgorithm_]=void 0,t[flushAlgorithm_]=void 0}function transformStreamDefaultControllerEnqueue(t,i){const a=t[controlledTransformStream_],n=a[readable_][readableStreamController_];if(!readableStreamDefaultControllerCanCloseOrEnqueue(n))throw new TypeError;try{readableStreamDefaultControllerEnqueue(n,i)}catch(o){throw transformStreamErrorWritableAndUnblockWrite(a,o),a[readable_][storedError_]}readableStreamDefaultControllerHasBackpressure(n)!==a[backpressure_$1]&&transformStreamSetBackpressure(a,!0)}function transformStreamDefaultControllerError(t,i){transformStreamError(t[controlledTransformStream_],i)}function transformStreamDefaultControllerPerformTransform(t,i){return t[transformAlgorithm_](i).catch((i=>{throw transformStreamError(t[controlledTransformStream_],i),i}))}function transformStreamDefaultControllerTerminate(t){const i=t[controlledTransformStream_],a=i[readable_][readableStreamController_];readableStreamDefaultControllerCanCloseOrEnqueue(a)&&readableStreamDefaultControllerClose(a);transformStreamErrorWritableAndUnblockWrite(i,new TypeError("The transform stream has been terminated"))}function transformStreamDefaultSinkWriteAlgorithm(t,i){const a=t[transformStreamController_];if(t[backpressure_$1]){return t[backpressureChangePromise_].promise.then((n=>{const o=t[writable_];if("erroring"===o[state_])throw o[storedError_];return transformStreamDefaultControllerPerformTransform(a,i)}))}return transformStreamDefaultControllerPerformTransform(a,i)}function transformStreamDefaultSinkAbortAlgorithm(t,i){return transformStreamError(t,i),Promise.resolve(void 0)}function transformStreamDefaultSinkCloseAlgorithm(t){const i=t[readable_],a=t[transformStreamController_],n=a[flushAlgorithm_]();return transformStreamDefaultControllerClearAlgorithms(a),n.then((t=>{if("errored"===i[state_])throw i[storedError_];const a=i[readableStreamController_];readableStreamDefaultControllerCanCloseOrEnqueue(a)&&readableStreamDefaultControllerClose(a)}),(a=>{throw transformStreamError(t,a),i[storedError_]}))}function transformStreamDefaultSourcePullAlgorithm(t){return transformStreamSetBackpressure(t,!1),t[backpressureChangePromise_].promise}class TransformStreamDefaultController{constructor(){throw new TypeError}get desiredSize(){if(!isTransformStreamDefaultController(this))throw new TypeError;return readableStreamDefaultControllerGetDesiredSize(this[controlledTransformStream_][readable_][readableStreamController_])}enqueue(t){if(!isTransformStreamDefaultController(this))throw new TypeError;transformStreamDefaultControllerEnqueue(this,t)}error(t){if(!isTransformStreamDefaultController(this))throw new TypeError;transformStreamDefaultControllerError(this,t)}terminate(){if(!isTransformStreamDefaultController(this))throw new TypeError;transformStreamDefaultControllerTerminate(this)}}class TransformStream$1{constructor(t={},i={},a={}){const n=i.size,o=i.highWaterMark,s=a.size,l=a.highWaterMark;if(void 0!==t.writableType)throw new RangeError("The transformer's `writableType` field must be undefined");const d=makeSizeAlgorithmFromSizeFunction(n),h=validateAndNormalizeHighWaterMark(void 0===o?1:o);if(void 0!==t.readableType)throw new RangeError("The transformer's `readableType` field must be undefined");const _=makeSizeAlgorithmFromSizeFunction(s),f=validateAndNormalizeHighWaterMark(void 0===l?0:l),m=createControlledPromise();initializeTransformStream(this,m.promise,h,d,f,_),setUpTransformStreamDefaultControllerFromTransformer(this,t);const b=invokeOrNoop(t,"start",[this[transformStreamController_]]);m.resolve(b)}get readable(){if(!isTransformStream(this))throw new TypeError;return this[readable_]}get writable(){if(!isTransformStream(this))throw new TypeError;return this[writable_]}}function setUpTransformStreamDefaultControllerFromTransformer(t,i){const a=Object.create(TransformStreamDefaultController.prototype);let n;const o=i.transform;if(void 0!==o){if("function"!=typeof o)throw new TypeError("`transform` field of the transformer must be a function");n=t=>promiseCall(o,i,[t,a])}else n=function(t){try{transformStreamDefaultControllerEnqueue(a,t)}catch(i){return Promise.reject(i)}return Promise.resolve(void 0)};const s=createAlgorithmFromUnderlyingMethod(i,"flush",[a]);setUpTransformStreamDefaultController(t,a,n,s)}class ByteLengthQueuingStrategy{constructor(t){this.highWaterMark=t.highWaterMark}size(t){return t.byteLength}}class CountQueuingStrategy{constructor(t){this.highWaterMark=t.highWaterMark}size(){return 1}}function wrapReadableStream(t,i){let a;return new i({start(i){a=t.getReader(),a.closed.catch((t=>{i.error(t)}))},pull:t=>a.read().then((({value:i,done:a})=>{a?t.close():t.enqueue(i)}),(i=>{t.error(i)})),cancel(t){a.cancel(t)}})}function getMIMETypeFromHeadersInit(t){const i="Content-Type";if(void 0===t)return"";if(t instanceof Headers)return t.get(i)||"";if(Array.isArray(t)){const a=t.find((t=>Array.isArray(t)&&2===t.length&&t[0]===i));return a?a[1]:""}return t[i]||""}function resolveRequestInitStream(t,i,a){if(void 0===t)return Promise.resolve(t);const n=t.body;let o;if(n&&"object"==typeof n&&(i&&n instanceof i||n instanceof a)&&(o=n),!o)return Promise.resolve(t);const s=getMIMETypeFromHeadersInit(t.headers);return readAllBytesFromStream(o.getReader(),s).then((i=>(t.body=i,t)))}function createAdaptedFetch(t,i,a,n,o){return function fetch(s,l){return resolveRequestInitStream(l,a,n).then((a=>t.call(void 0,s,a).then((t=>{if("body"in t){const a=t;let s,d;t=new Proxy(a,{get(h,_,f){let m;return"body"===_?(void 0===s&&(s=wrapReadableStream(a.body,n)),m=s):"clone"===_?(void 0===d&&(d=function(){const[a,n]=o(t.body,!0);return s=a,createResponseProxyWithStreamBody(i,o,n,l)}),m=d):m=h[_],"function"==typeof m?function(...t){return m.apply(h,t)}:m}})}else t.body=new n({pull:i=>t.arrayBuffer().then((t=>{i.enqueue(new Uint8Array(t)),i.close()}),(t=>{i.error(t)}))}),t.clone=function(){const[a,n]=o(t.body,!0);return t.body=a,createResponseProxyWithStreamBody(i,o,n,l)};return t}))))}}function readAllBytesFromStream(t,i){return new Promise(((a,n)=>{const o=[];!function readNext(){t.read().then((({value:t,done:s})=>{s?function completeRead(){0===o.length&&o.push(new Uint8Array(0));const t=new Blob(o,{type:i});a(t)}():t instanceof Uint8Array?(o.push(t),readNext()):n(new TypeError("A ReadableStream body must only yield Uint8Array values"))}),(t=>{n(t)}))}()}))}function createResponseProxyWithStreamBody(t,i,a,n){const o=new t("fake",n),s=getMIMETypeFromHeadersInit(o.headers);let l,d=!1;function getFinalResponse(){return void 0===l&&(l=new Promise(((i,o)=>{if(d=!0,a.locked)return o(new TypeError("The ReadableStream is locked"));readAllBytesFromStream(a.getReader(),s).then((a=>{i(new t(a,n))})).catch((t=>{o(t)}))}))),l}return new class Response{get type(){return o.type}get url(){return o.url}get redirected(){return o.redirected}get status(){return o.status}get ok(){return o.ok}get statusText(){return o.statusText}get headers(){return o.headers}clone(){const[o,s]=i(a,!0);return a=o,createResponseProxyWithStreamBody(t,i,s,n)}get body(){return a}get bodyUsed(){return d}arrayBuffer(){return getFinalResponse().then((t=>t.arrayBuffer()))}blob(){return getFinalResponse().then((t=>t.blob()))}formData(){return getFinalResponse().then((t=>t.formData()))}json(){return getFinalResponse().then((t=>t.json()))}text(){return getFinalResponse().then((t=>t.text()))}}}function createAdaptedResponse(t,i,a,n){const wrappedResponse=function(o,s){if(o instanceof a){if(void 0===i||!("body"in t))return createResponseProxyWithStreamBody(t,n,o,s);o=wrapReadableStream(o,i)}return new t(o,s)};return wrappedResponse.prototype=t.prototype,wrappedResponse}const decDecoder=Symbol("decDecoder"),decTransform=Symbol("decTransform");class TextDecodeTransformer{constructor(t){this.decoder_=t}transform(t,i){if(!(t instanceof ArrayBuffer||ArrayBuffer.isView(t)))throw new TypeError("Input data must be a BufferSource");const a=this.decoder_.decode(t,{stream:!0});0!==a.length&&i.enqueue(a)}flush(t){const i=this.decoder_.decode();0!==i.length&&t.enqueue(i)}}class TextDecoderStream{constructor(t,i){this[decDecoder]=new TextDecoder(t,i),this[decTransform]=new TransformStream(new TextDecodeTransformer(this[decDecoder]))}get encoding(){return this[decDecoder].encoding}get fatal(){return this[decDecoder].fatal}get ignoreBOM(){return this[decDecoder].ignoreBOM}get readable(){return this[decTransform].readable}get writable(){return this[decTransform].writable}}const encEncoder=Symbol("encEncoder"),encTransform=Symbol("encTransform");class TextEncodeTransformer{constructor(t){this.encoder_=t,this.partial_=void 0}transform(t,i){let a=String(t);void 0!==this.partial_&&(a=this.partial_+a,this.partial_=void 0);const n=a.length-1,o=a.charCodeAt(n);o>=55296&&o<56320&&(this.partial_=String.fromCharCode(o),a=a.substring(0,n));const s=this.encoder_.encode(a);0!==s.length&&i.enqueue(s)}flush(t){this.partial_&&(t.enqueue(this.encoder_.encode(this.partial_)),this.partial_=void 0)}}class TextEncoderStream{constructor(){this[encEncoder]=new TextEncoder,this[encTransform]=new TransformStream(new TextEncodeTransformer(this[encEncoder]))}get encoding(){return this[encEncoder].encoding}get readable(){return this[encTransform].readable}get writable(){return this[encTransform].writable}}const PRESET_DICT=32,Z_DEFLATED=8,GZIP_ID1=31,GZIP_ID2=139,inflate_mask=[0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535],swap32=t=>(t>>>24&255|t>>>8&65280|(65280&t)<<8|(255&t)<<24)>>>0;function u8ArrayFromBufferSource(t){return t instanceof ArrayBuffer?new Uint8Array(t):ArrayBuffer.isView(t)?t instanceof Uint8Array?t:new Uint8Array(t.buffer,t.byteOffset,t.byteLength):void 0}function adler32(t,i=1){const a=u8ArrayFromBufferSource(t);if(!a)throw new TypeError("source must be a BufferSource");return computeAdler32(a,i)}const BASE=65521,NMAX=5552;function computeAdler32(t,i=1){let a=i>>>16&65535;i&=65535;let n=t.length,o=0;for(;n>=NMAX;){n-=NMAX;let s=NMAX/16;do{a+=i+=t[o++],a+=i+=t[o++],a+=i+=t[o++],a+=i+=t[o++],a+=i+=t[o++],a+=i+=t[o++],a+=i+=t[o++],a+=i+=t[o++],a+=i+=t[o++],a+=i+=t[o++],a+=i+=t[o++],a+=i+=t[o++],a+=i+=t[o++],a+=i+=t[o++],a+=i+=t[o++],a+=i+=t[o++]}while(--s);i%=BASE,a+=BASE}if(n){for(;n>=16;)n-=16,a+=i+=t[o++],a+=i+=t[o++],a+=i+=t[o++],a+=i+=t[o++],a+=i+=t[o++],a+=i+=t[o++],a+=i+=t[o++],a+=i+=t[o++],a+=i+=t[o++],a+=i+=t[o++],a+=i+=t[o++],a+=i+=t[o++],a+=i+=t[o++],a+=i+=t[o++],a+=i+=t[o++],a+=i+=t[o++];for(;n--;)a+=i+=t[o++];i%=BASE,a%=BASE}return i|a<<16}function crc32(t,i=0){const a=u8ArrayFromBufferSource(t);if(!a)throw new TypeError("source must be a BufferSource");return computeCRC32(a,i)}const endian=new Uint32Array([1]),endianCheck=new Uint8Array(endian.buffer,0,1)[0],computeCRC32=1===endianCheck?computeCRC32Little:computeCRC32Big;function computeCRC32Little(t,i=0){let a=~i,n=t.byteOffset,o=0,s=t.byteLength;const l=crcTables[0],d=crcTables[1],h=crcTables[2],_=crcTables[3];for(;s&&3&n;)a=l[255&(a^t[o++])]^a>>>8,s--,n++;const f=new Uint32Array(t.buffer,n,s>>>2);let m=0;for(;s>=32;)a^=f[m++],a=_[255&a]^h[a>>>8&255]^d[a>>>16&255]^l[a>>>24],a^=f[m++],a=_[255&a]^h[a>>>8&255]^d[a>>>16&255]^l[a>>>24],a^=f[m++],a=_[255&a]^h[a>>>8&255]^d[a>>>16&255]^l[a>>>24],a^=f[m++],a=_[255&a]^h[a>>>8&255]^d[a>>>16&255]^l[a>>>24],a^=f[m++],a=_[255&a]^h[a>>>8&255]^d[a>>>16&255]^l[a>>>24],a^=f[m++],a=_[255&a]^h[a>>>8&255]^d[a>>>16&255]^l[a>>>24],a^=f[m++],a=_[255&a]^h[a>>>8&255]^d[a>>>16&255]^l[a>>>24],a^=f[m++],a=_[255&a]^h[a>>>8&255]^d[a>>>16&255]^l[a>>>24],s-=32;for(;s>=4;)a^=f[m++],a=_[255&a]^h[a>>>8&255]^d[a>>>16&255]^l[a>>>24],s-=4;if(s){o+=4*m;do{a=l[255&(a^t[o++])]^a>>>8}while(--s)}return a=~a,a}function computeCRC32Big(t,i=0){let a=~swap32(i),n=t.byteOffset,o=0,s=t.byteLength;const l=crcTables[4],d=crcTables[5],h=crcTables[6],_=crcTables[7];for(;s&&3&n;)a=l[a>>>24^t[o++]]^a<<8,s--,n++;const f=new Uint32Array(t.buffer,n,s>>>2);let m=0;for(;s>=32;)a^=f[m++],a=l[255&a]^d[a>>>8&255]^h[a>>>16&255]^_[a>>>24],a^=f[m++],a=l[255&a]^d[a>>>8&255]^h[a>>>16&255]^_[a>>>24],a^=f[m++],a=l[255&a]^d[a>>>8&255]^h[a>>>16&255]^_[a>>>24],a^=f[m++],a=l[255&a]^d[a>>>8&255]^h[a>>>16&255]^_[a>>>24],a^=f[m++],a=l[255&a]^d[a>>>8&255]^h[a>>>16&255]^_[a>>>24],a^=f[m++],a=l[255&a]^d[a>>>8&255]^h[a>>>16&255]^_[a>>>24],a^=f[m++],a=l[255&a]^d[a>>>8&255]^h[a>>>16&255]^_[a>>>24],a^=f[m++],a=l[255&a]^d[a>>>8&255]^h[a>>>16&255]^_[a>>>24],s-=32;for(;s>=4;)a^=f[m++],a=l[255&a]^d[a>>>8&255]^h[a>>>16&255]^_[a>>>24],s-=4;if(s){o+=4*m;do{a=l[a>>>24^t[o++]]^a<<8}while(--s)}return a=~a,swap32(a)}function makeCRCTables(){const t=new ArrayBuffer(8192),i=[new Uint32Array(t,0,256),new Uint32Array(t,1024,256),new Uint32Array(t,2048,256),new Uint32Array(t,3072,256),new Uint32Array(t,4096,256),new Uint32Array(t,5120,256),new Uint32Array(t,6144,256),new Uint32Array(t,7168,256)];for(let a=0;a<256;a++){let t=a;for(let i=0;i<8;i++)t=1&t?3988292384^t>>>1:t>>>1;i[0][a]=t,i[4][a]=swap32(t)}for(let a=0;a<256;a++){let t=i[0][a];for(let n=1;n<4;n++)t=i[0][255&t]^t>>>8,i[n][a]=t,i[n+4][a]=swap32(t)}return i}const crcTables=makeCRCTables(),OUTPUT_BUFSIZE=16384;class ZStream{constructor(){this.avail_in=0,this.next_in_index=0,this.next_out=new Uint8Array(OUTPUT_BUFSIZE),this.avail_out=this.next_out.byteLength,this.next_out_index=0,this.total_in=this.total_out=0,this.msg=""}append(t){this.next_in=t,this.avail_in=t.length,this.next_in_index=0}read_buf(t,i){return this.next_in.subarray(t,t+i)}read_into_buf(t,i,a){let n=this.avail_in;return n>a&&(n=a),0===n?0:(t.set(this.next_in.subarray(this.next_in_index,this.next_in_index+n),i),this.avail_in-=n,this.next_in_index+=n,this.total_in+=n,n)}flush_pending(t){var i=t.pending;i>this.avail_out&&(i=this.avail_out),0!==i&&(this.next_out.set(t.pending_buf.subarray(t.pending_out,t.pending_out+i),this.next_out_index),this.next_out_index+=i,t.pending_out+=i,this.total_out+=i,this.avail_out-=i,t.pending-=i,0===t.pending&&(t.pending_out=0))}}function InfCodes(){let t,i,a,n,o=0,s=0,l=0,d=0,h=0,_=0,f=0,m=0,b=0,S=0;function inflate_fast(t,i,a,n,o,s,l,d){let h,_,f,m,b,S,w,p,y,g,C,R,E,k,A,T;w=d.next_in_index,p=d.avail_in,b=l.bitb,S=l.bitk,y=l.write,g=y<l.read?l.read-y-1:l.end-y,C=inflate_mask[t],R=inflate_mask[i];do{for(;S<20;)p--,b|=(255&d.next_in[w++])<<S,S+=8;if(h=b&C,_=a,f=n,T=3*(f+h),m=_[T],0!==m)for(;;){if(b>>=_[T+1],S-=_[T+1],0!=(16&m)){for(m&=15,E=_[T+2]+(b&inflate_mask[m]),b>>=m,S-=m;S<15;)p--,b|=(255&d.next_in[w++])<<S,S+=8;for(h=b&R,_=o,f=s,T=3*(f+h),m=_[T];;){if(b>>=_[T+1],S-=_[T+1],0!=(16&m)){for(m&=15;S<m;)p--,b|=(255&d.next_in[w++])<<S,S+=8;if(k=_[T+2]+(b&inflate_mask[m]),b>>=m,S-=m,g-=E,y>=k)A=y-k,l.window[y++]=l.window[A++],l.window[y++]=l.window[A++],E-=2;else{A=y-k;do{A+=l.end}while(A<0);if(m=l.end-A,E>m){E-=m;do{l.window[y++]=l.window[A++]}while(0!=--m);A=0}}do{l.window[y++]=l.window[A++]}while(0!=--E);break}if(0!=(64&m))return d.msg="invalid distance code",E=d.avail_in-p,E=S>>3<E?S>>3:E,p+=E,w-=E,S-=E<<3,l.bitb=b,l.bitk=S,d.avail_in=p,d.total_in+=w-d.next_in_index,d.next_in_index=w,l.write=y,-3;h+=_[T+2],h+=b&inflate_mask[m],T=3*(f+h),m=_[T]}break}if(0!=(64&m))return 0!=(32&m)?(E=d.avail_in-p,E=S>>3<E?S>>3:E,p+=E,w-=E,S-=E<<3,l.bitb=b,l.bitk=S,d.avail_in=p,d.total_in+=w-d.next_in_index,d.next_in_index=w,l.write=y,1):(d.msg="invalid literal/length code",E=d.avail_in-p,E=S>>3<E?S>>3:E,p+=E,w-=E,S-=E<<3,l.bitb=b,l.bitk=S,d.avail_in=p,d.total_in+=w-d.next_in_index,d.next_in_index=w,l.write=y,-3);if(h+=_[T+2],h+=b&inflate_mask[m],T=3*(f+h),m=_[T],0===m){b>>=_[T+1],S-=_[T+1],l.window[y++]=_[T+2],g--;break}}else b>>=_[T+1],S-=_[T+1],l.window[y++]=_[T+2],g--}while(g>=258&&p>=10);return E=d.avail_in-p,E=S>>3<E?S>>3:E,p+=E,w-=E,S-=E<<3,l.bitb=b,l.bitk=S,d.avail_in=p,d.total_in+=w-d.next_in_index,d.next_in_index=w,l.write=y,0}return{init:function init(i,o,s,l,d,h){t=0,f=i,m=o,a=s,b=l,n=d,S=h},proc:function proc(w,p,y){let g,C,R,E,k,A,T,D=0,B=0,P=0;for(P=p.next_in_index,E=p.avail_in,D=w.bitb,B=w.bitk,k=w.write,A=k<w.read?w.read-k-1:w.end-k;;)switch(t){case 0:if(A>=258&&E>=10&&(w.bitb=D,w.bitk=B,p.avail_in=E,p.total_in+=P-p.next_in_index,p.next_in_index=P,w.write=k,y=inflate_fast(f,m,a,b,n,S,w,p),P=p.next_in_index,E=p.avail_in,D=w.bitb,B=w.bitk,k=w.write,A=k<w.read?w.read-k-1:w.end-k,0!==y)){t=1===y?7:9;break}l=f,i=a,s=b,t=1;case 1:for(g=l;B<g;){if(0===E)return w.bitb=D,w.bitk=B,p.avail_in=E,p.total_in+=P-p.next_in_index,p.next_in_index=P,w.write=k,w.inflate_flush(p,y);y=0,E--,D|=(255&p.next_in[P++])<<B,B+=8}if(C=3*(s+(D&inflate_mask[g])),D>>>=i[C+1],B-=i[C+1],R=i[C],0===R){d=i[C+2],t=6;break}if(0!=(16&R)){h=15&R,o=i[C+2],t=2;break}if(0==(64&R)){l=R,s=C/3+i[C+2];break}if(0!=(32&R)){t=7;break}return t=9,p.msg="invalid literal/length code",y=-3,w.bitb=D,w.bitk=B,p.avail_in=E,p.total_in+=P-p.next_in_index,p.next_in_index=P,w.write=k,w.inflate_flush(p,y);case 2:for(g=h;B<g;){if(0===E)return w.bitb=D,w.bitk=B,p.avail_in=E,p.total_in+=P-p.next_in_index,p.next_in_index=P,w.write=k,w.inflate_flush(p,y);y=0,E--,D|=(255&p.next_in[P++])<<B,B+=8}o+=D&inflate_mask[g],D>>=g,B-=g,l=m,i=n,s=S,t=3;case 3:for(g=l;B<g;){if(0===E)return w.bitb=D,w.bitk=B,p.avail_in=E,p.total_in+=P-p.next_in_index,p.next_in_index=P,w.write=k,w.inflate_flush(p,y);y=0,E--,D|=(255&p.next_in[P++])<<B,B+=8}if(C=3*(s+(D&inflate_mask[g])),D>>=i[C+1],B-=i[C+1],R=i[C],0!=(16&R)){h=15&R,_=i[C+2],t=4;break}if(0==(64&R)){l=R,s=C/3+i[C+2];break}return t=9,p.msg="invalid distance code",y=-3,w.bitb=D,w.bitk=B,p.avail_in=E,p.total_in+=P-p.next_in_index,p.next_in_index=P,w.write=k,w.inflate_flush(p,y);case 4:for(g=h;B<g;){if(0===E)return w.bitb=D,w.bitk=B,p.avail_in=E,p.total_in+=P-p.next_in_index,p.next_in_index=P,w.write=k,w.inflate_flush(p,y);y=0,E--,D|=(255&p.next_in[P++])<<B,B+=8}_+=D&inflate_mask[g],D>>=g,B-=g,t=5;case 5:for(T=k-_;T<0;)T+=w.end;for(;0!==o;){if(0===A&&(k===w.end&&0!==w.read&&(k=0,A=k<w.read?w.read-k-1:w.end-k),0===A&&(w.write=k,y=w.inflate_flush(p,y),k=w.write,A=k<w.read?w.read-k-1:w.end-k,k===w.end&&0!==w.read&&(k=0,A=k<w.read?w.read-k-1:w.end-k),0===A)))return w.bitb=D,w.bitk=B,p.avail_in=E,p.total_in+=P-p.next_in_index,p.next_in_index=P,w.write=k,w.inflate_flush(p,y);w.window[k++]=w.window[T++],A--,T===w.end&&(T=0),o--}t=0;break;case 6:if(0===A&&(k===w.end&&0!==w.read&&(k=0,A=k<w.read?w.read-k-1:w.end-k),0===A&&(w.write=k,y=w.inflate_flush(p,y),k=w.write,A=k<w.read?w.read-k-1:w.end-k,k===w.end&&0!==w.read&&(k=0,A=k<w.read?w.read-k-1:w.end-k),0===A)))return w.bitb=D,w.bitk=B,p.avail_in=E,p.total_in+=P-p.next_in_index,p.next_in_index=P,w.write=k,w.inflate_flush(p,y);y=0,w.window[k++]=d,A--,t=0;break;case 7:if(B>7&&(B-=8,E++,P--),w.write=k,y=w.inflate_flush(p,y),k=w.write,A=k<w.read?w.read-k-1:w.end-k,w.read!==w.write)return w.bitb=D,w.bitk=B,p.avail_in=E,p.total_in+=P-p.next_in_index,p.next_in_index=P,w.write=k,w.inflate_flush(p,y);t=8;case 8:return y=1,w.bitb=D,w.bitk=B,p.avail_in=E,p.total_in+=P-p.next_in_index,p.next_in_index=P,w.write=k,w.inflate_flush(p,y);case 9:return y=-3,w.bitb=D,w.bitk=B,p.avail_in=E,p.total_in+=P-p.next_in_index,p.next_in_index=P,w.write=k,w.inflate_flush(p,y);default:return y=-2,w.bitb=D,w.bitk=B,p.avail_in=E,p.total_in+=P-p.next_in_index,p.next_in_index=P,w.write=k,w.inflate_flush(p,y)}}}}const fixed_bl=9,fixed_bd=5,fixed_tl=[96,7,256,0,8,80,0,8,16,84,8,115,82,7,31,0,8,112,0,8,48,0,9,192,80,7,10,0,8,96,0,8,32,0,9,160,0,8,0,0,8,128,0,8,64,0,9,224,80,7,6,0,8,88,0,8,24,0,9,144,83,7,59,0,8,120,0,8,56,0,9,208,81,7,17,0,8,104,0,8,40,0,9,176,0,8,8,0,8,136,0,8,72,0,9,240,80,7,4,0,8,84,0,8,20,85,8,227,83,7,43,0,8,116,0,8,52,0,9,200,81,7,13,0,8,100,0,8,36,0,9,168,0,8,4,0,8,132,0,8,68,0,9,232,80,7,8,0,8,92,0,8,28,0,9,152,84,7,83,0,8,124,0,8,60,0,9,216,82,7,23,0,8,108,0,8,44,0,9,184,0,8,12,0,8,140,0,8,76,0,9,248,80,7,3,0,8,82,0,8,18,85,8,163,83,7,35,0,8,114,0,8,50,0,9,196,81,7,11,0,8,98,0,8,34,0,9,164,0,8,2,0,8,130,0,8,66,0,9,228,80,7,7,0,8,90,0,8,26,0,9,148,84,7,67,0,8,122,0,8,58,0,9,212,82,7,19,0,8,106,0,8,42,0,9,180,0,8,10,0,8,138,0,8,74,0,9,244,80,7,5,0,8,86,0,8,22,192,8,0,83,7,51,0,8,118,0,8,54,0,9,204,81,7,15,0,8,102,0,8,38,0,9,172,0,8,6,0,8,134,0,8,70,0,9,236,80,7,9,0,8,94,0,8,30,0,9,156,84,7,99,0,8,126,0,8,62,0,9,220,82,7,27,0,8,110,0,8,46,0,9,188,0,8,14,0,8,142,0,8,78,0,9,252,96,7,256,0,8,81,0,8,17,85,8,131,82,7,31,0,8,113,0,8,49,0,9,194,80,7,10,0,8,97,0,8,33,0,9,162,0,8,1,0,8,129,0,8,65,0,9,226,80,7,6,0,8,89,0,8,25,0,9,146,83,7,59,0,8,121,0,8,57,0,9,210,81,7,17,0,8,105,0,8,41,0,9,178,0,8,9,0,8,137,0,8,73,0,9,242,80,7,4,0,8,85,0,8,21,80,8,258,83,7,43,0,8,117,0,8,53,0,9,202,81,7,13,0,8,101,0,8,37,0,9,170,0,8,5,0,8,133,0,8,69,0,9,234,80,7,8,0,8,93,0,8,29,0,9,154,84,7,83,0,8,125,0,8,61,0,9,218,82,7,23,0,8,109,0,8,45,0,9,186,0,8,13,0,8,141,0,8,77,0,9,250,80,7,3,0,8,83,0,8,19,85,8,195,83,7,35,0,8,115,0,8,51,0,9,198,81,7,11,0,8,99,0,8,35,0,9,166,0,8,3,0,8,131,0,8,67,0,9,230,80,7,7,0,8,91,0,8,27,0,9,150,84,7,67,0,8,123,0,8,59,0,9,214,82,7,19,0,8,107,0,8,43,0,9,182,0,8,11,0,8,139,0,8,75,0,9,246,80,7,5,0,8,87,0,8,23,192,8,0,83,7,51,0,8,119,0,8,55,0,9,206,81,7,15,0,8,103,0,8,39,0,9,174,0,8,7,0,8,135,0,8,71,0,9,238,80,7,9,0,8,95,0,8,31,0,9,158,84,7,99,0,8,127,0,8,63,0,9,222,82,7,27,0,8,111,0,8,47,0,9,190,0,8,15,0,8,143,0,8,79,0,9,254,96,7,256,0,8,80,0,8,16,84,8,115,82,7,31,0,8,112,0,8,48,0,9,193,80,7,10,0,8,96,0,8,32,0,9,161,0,8,0,0,8,128,0,8,64,0,9,225,80,7,6,0,8,88,0,8,24,0,9,145,83,7,59,0,8,120,0,8,56,0,9,209,81,7,17,0,8,104,0,8,40,0,9,177,0,8,8,0,8,136,0,8,72,0,9,241,80,7,4,0,8,84,0,8,20,85,8,227,83,7,43,0,8,116,0,8,52,0,9,201,81,7,13,0,8,100,0,8,36,0,9,169,0,8,4,0,8,132,0,8,68,0,9,233,80,7,8,0,8,92,0,8,28,0,9,153,84,7,83,0,8,124,0,8,60,0,9,217,82,7,23,0,8,108,0,8,44,0,9,185,0,8,12,0,8,140,0,8,76,0,9,249,80,7,3,0,8,82,0,8,18,85,8,163,83,7,35,0,8,114,0,8,50,0,9,197,81,7,11,0,8,98,0,8,34,0,9,165,0,8,2,0,8,130,0,8,66,0,9,229,80,7,7,0,8,90,0,8,26,0,9,149,84,7,67,0,8,122,0,8,58,0,9,213,82,7,19,0,8,106,0,8,42,0,9,181,0,8,10,0,8,138,0,8,74,0,9,245,80,7,5,0,8,86,0,8,22,192,8,0,83,7,51,0,8,118,0,8,54,0,9,205,81,7,15,0,8,102,0,8,38,0,9,173,0,8,6,0,8,134,0,8,70,0,9,237,80,7,9,0,8,94,0,8,30,0,9,157,84,7,99,0,8,126,0,8,62,0,9,221,82,7,27,0,8,110,0,8,46,0,9,189,0,8,14,0,8,142,0,8,78,0,9,253,96,7,256,0,8,81,0,8,17,85,8,131,82,7,31,0,8,113,0,8,49,0,9,195,80,7,10,0,8,97,0,8,33,0,9,163,0,8,1,0,8,129,0,8,65,0,9,227,80,7,6,0,8,89,0,8,25,0,9,147,83,7,59,0,8,121,0,8,57,0,9,211,81,7,17,0,8,105,0,8,41,0,9,179,0,8,9,0,8,137,0,8,73,0,9,243,80,7,4,0,8,85,0,8,21,80,8,258,83,7,43,0,8,117,0,8,53,0,9,203,81,7,13,0,8,101,0,8,37,0,9,171,0,8,5,0,8,133,0,8,69,0,9,235,80,7,8,0,8,93,0,8,29,0,9,155,84,7,83,0,8,125,0,8,61,0,9,219,82,7,23,0,8,109,0,8,45,0,9,187,0,8,13,0,8,141,0,8,77,0,9,251,80,7,3,0,8,83,0,8,19,85,8,195,83,7,35,0,8,115,0,8,51,0,9,199,81,7,11,0,8,99,0,8,35,0,9,167,0,8,3,0,8,131,0,8,67,0,9,231,80,7,7,0,8,91,0,8,27,0,9,151,84,7,67,0,8,123,0,8,59,0,9,215,82,7,19,0,8,107,0,8,43,0,9,183,0,8,11,0,8,139,0,8,75,0,9,247,80,7,5,0,8,87,0,8,23,192,8,0,83,7,51,0,8,119,0,8,55,0,9,207,81,7,15,0,8,103,0,8,39,0,9,175,0,8,7,0,8,135,0,8,71,0,9,239,80,7,9,0,8,95,0,8,31,0,9,159,84,7,99,0,8,127,0,8,63,0,9,223,82,7,27,0,8,111,0,8,47,0,9,191,0,8,15,0,8,143,0,8,79,0,9,255],fixed_td=[80,5,1,87,5,257,83,5,17,91,5,4097,81,5,5,89,5,1025,85,5,65,93,5,16385,80,5,3,88,5,513,84,5,33,92,5,8193,82,5,9,90,5,2049,86,5,129,192,5,24577,80,5,2,87,5,385,83,5,25,91,5,6145,81,5,7,89,5,1537,85,5,97,93,5,24577,80,5,4,88,5,769,84,5,49,92,5,12289,82,5,13,90,5,3073,86,5,193,192,5,24577],cplens=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],cplext=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,112,112],cpdist=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],cpdext=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],BMAX=15;let v;const hn=[0],c=new Int32Array(BMAX+1),r=new Int32Array(3),u=new Int32Array(BMAX),x=new Int32Array(BMAX+1);function huft_build(t,i,a,n,o,s,l,d,h,_,f){let m,b,S,w,p,y,g,C,R,E,k,A,T,D,B;E=0,p=a;do{c[t[i+E]]++,E++,p--}while(0!==p);if(c[0]===a)return l[0]=-1,d[0]=0,0;for(C=d[0],y=1;y<=BMAX&&0===c[y];y++);for(g=y,C<y&&(C=y),p=BMAX;0!==p&&0===c[p];p--);for(S=p,C>p&&(C=p),d[0]=C,D=1<<y;y<p;y++,D<<=1)if(D-=c[y],D<0)return-3;if(D-=c[p],D<0)return-3;for(c[p]+=D,x[1]=y=0,E=1,T=2;0!=--p;)x[T]=y+=c[E],T++,E++;p=0,E=0;do{y=t[i+E],0!==y&&(f[x[y]++]=p),E++}while(++p<a);for(a=x[S],x[0]=p=0,E=0,w=-1,A=-C,u[0]=0,k=0,B=0;g<=S;g++)for(m=c[g];0!=m--;){for(;g>A+C;){if(w++,A+=C,B=S-A,B=B>C?C:B,b=1<<(y=g-A),b>m+1&&(b-=m+1,T=g,y<B))for(;++y<B&&(b<<=1,!(b<=c[++T]));)b-=c[T];if(B=1<<y,_[0]+B>1400)return-3;u[w]=k=_[0],_[0]+=B,0!==w?(x[w]=p,r[0]=y,r[1]=C,y=p>>>A-C,r[2]=k-u[w-1]-y,h.set(r,3*(u[w-1]+y))):l[0]=k}for(r[1]=g-A,E>=a?r[0]=192:f[E]<n?(r[0]=f[E]<256?0:96,r[2]=f[E++]):(r[0]=s[f[E]-n]+16+64,r[2]=o[f[E++]-n]),b=1<<g-A,y=p>>>A;y<B;y+=b)h.set(r,3*(k+y));for(y=1<<g-1;0!=(p&y);y>>>=1)p^=y;for(p^=y,R=(1<<A)-1;(p&R)!==x[w];)w--,A-=C,R=(1<<A)-1}return 0!==D&&1!==S?-5:0}function initWorkArea(t){v=new Int32Array(t);for(let i=0;i<BMAX+1;i++)c[i]=0,u[i]=0,x[i]=0;for(let i=0;i<3;i++)r[i]=0}function inflate_trees_bits(t,i,a,n,o){initWorkArea(19),hn[0]=0;let s=huft_build(t,0,19,19,null,null,a,i,n,hn,v);return-3===s?o.msg="oversubscribed dynamic bit lengths tree":-5!==s&&0!==i[0]||(o.msg="incomplete dynamic bit lengths tree",s=-3),s}function inflate_trees_dynamic(t,i,a,n,o,s,l,d,h){initWorkArea(288),hn[0]=0;let _=huft_build(a,0,t,257,cplens,cplext,s,n,d,hn,v);return 0!==_||0===n[0]?(-3===_?h.msg="oversubscribed literal/length tree":(h.msg="incomplete literal/length tree",_=-3),_):(initWorkArea(288),_=huft_build(a,t,i,0,cpdist,cpdext,l,o,d,hn,v),0!==_||0===o[0]&&t>257?(-3===_?h.msg="oversubscribed distance tree":-5===_?(h.msg="incomplete distance tree",_=-3):(h.msg="empty distance tree with lengths",_=-3),_):0)}function inflate_trees_fixed(t,i,a,n){return t[0]=fixed_bl,i[0]=fixed_bd,a[0]=fixed_tl,n[0]=fixed_td,0}const border=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];class InfBlocks{constructor(t){this.codes=InfCodes(),this.hufts=new Int32Array(4200),this.mode=0,this.bitk=0,this.bitb=0,this.read=0,this.write=0,this.last=0,this.end=t,this.window=new Uint8Array(t)}reset(){this.bitk=0,this.bitb=0,this.read=0,this.write=0,this.last=0}inflate_flush(t,i){let a,n,o;return n=t.next_out_index,o=this.read,a=(o<=this.write?this.write:this.end)-o,a>t.avail_out&&(a=t.avail_out),0!==a&&-5===i&&(i=0),t.avail_out-=a,t.total_out+=a,t.next_out.set(this.window.subarray(o,o+a),n),n+=a,o+=a,o===this.end&&(o=0,this.write===this.end&&(this.write=0),a=this.write-o,a>t.avail_out&&(a=t.avail_out),0!==a&&-5===i&&(i=0),t.avail_out-=a,t.total_out+=a,t.next_out.set(this.window.subarray(o,o+a),n),n+=a,o+=a),t.next_out_index=n,this.read=o,i}proc(t,i){let a,n,o,s,l,d,h,_,f=0,m=0,b=0;const S=new Uint8Array(320),w=[0],p=[0],y=this.codes,g=this.hufts;for(s=t.next_in_index,l=t.avail_in,n=this.bitb,o=this.bitk,d=this.write,h=d<this.read?this.read-d-1:this.end-d;;)switch(this.mode){case 0:if(this.last)return 1;for(;o<3;){if(0===l)return this.bitb=n,this.bitk=o,t.avail_in=l,t.total_in+=s-t.next_in_index,t.next_in_index=s,this.write=d,this.inflate_flush(t,i);i=0,l--,n|=(255&t.next_in[s++])<<o,o+=8}switch(a=7&n,this.last=1&a,a>>>1){case 0:n>>>=3,o-=3,a=7&o,n>>>=a,o-=a,this.mode=1;break;case 1:const h=[0],_=[0],f=[[]],m=[[]];inflate_trees_fixed(h,_,f,m),y.init(h[0],_[0],f[0],0,m[0],0),n>>>=3,o-=3,this.mode=6;break;case 2:n>>>=3,o-=3,this.mode=3;break;case 3:return n>>>=3,o-=3,this.mode=9,t.msg="invalid block type",i=-3,this.bitb=n,this.bitk=o,t.avail_in=l,t.total_in+=s-t.next_in_index,t.next_in_index=s,this.write=d,this.inflate_flush(t,i)}break;case 1:for(;o<32;){if(0===l)return this.bitb=n,this.bitk=o,t.avail_in=l,t.total_in+=s-t.next_in_index,t.next_in_index=s,this.write=d,this.inflate_flush(t,i);i=0,l--,n|=(255&t.next_in[s++])<<o,o+=8}if((~n>>>16&65535)!=(65535&n))return this.mode=9,t.msg="invalid stored block lengths",i=-3,this.bitb=n,this.bitk=o,t.avail_in=l,t.total_in+=s-t.next_in_index,t.next_in_index=s,this.write=d,this.inflate_flush(t,i);f=65535&n,n=o=0,this.mode=0!==f?2:0!==this.last?7:0;break;case 2:if(0===l)return this.bitb=n,this.bitk=o,t.avail_in=l,t.total_in+=s-t.next_in_index,t.next_in_index=s,this.write=d,this.inflate_flush(t,i);if(0===h&&(d===this.end&&0!==this.read&&(d=0,h=d<this.read?this.read-d-1:this.end-d),0===h&&(this.write=d,i=this.inflate_flush(t,i),d=this.write,h=d<this.read?this.read-d-1:this.end-d,d===this.end&&0!==this.read&&(d=0,h=d<this.read?this.read-d-1:this.end-d),0===h)))return this.bitb=n,this.bitk=o,t.avail_in=l,t.total_in+=s-t.next_in_index,t.next_in_index=s,this.write=d,this.inflate_flush(t,i);if(i=0,a=f,a>l&&(a=l),a>h&&(a=h),this.window.set(t.read_buf(s,a),d),s+=a,l-=a,d+=a,h-=a,f-=a,0!==f)break;this.mode=0!==this.last?7:0;break;case 3:for(;o<14;){if(0===l)return this.bitb=n,this.bitk=o,t.avail_in=l,t.total_in+=s-t.next_in_index,t.next_in_index=s,this.write=d,this.inflate_flush(t,i);i=0,l--,n|=(255&t.next_in[s++])<<o,o+=8}if(m=a=16383&n,(31&a)>29||(a>>5&31)>29)return this.mode=9,t.msg="too many length or distance symbols",i=-3,this.bitb=n,this.bitk=o,t.avail_in=l,t.total_in+=s-t.next_in_index,t.next_in_index=s,this.write=d,this.inflate_flush(t,i);for(a=258+(31&a)+(a>>5&31),_=0;_<a;_++)S[_]=0;for(n>>>=14,o-=14,b=0,this.mode=4;b<4+(m>>>10);){for(;o<3;){if(0===l)return this.bitb=n,this.bitk=o,t.avail_in=l,t.total_in+=s-t.next_in_index,t.next_in_index=s,this.write=d,this.inflate_flush(t,i);i=0,l--,n|=(255&t.next_in[s++])<<o,o+=8}S[border[b++]]=7&n,n>>>=3,o-=3}for(;b<19;)S[border[b++]]=0;if(w[0]=7,a=inflate_trees_bits(S,w,p,g,t),0!==a)return-3===(i=a)&&(this.mode=9),this.bitb=n,this.bitk=o,t.avail_in=l,t.total_in+=s-t.next_in_index,t.next_in_index=s,this.write=d,this.inflate_flush(t,i);for(b=0,this.mode=5;a=m,!(b>=258+(31&a)+(a>>5&31));){let h,f;for(a=w[0];o<a;){if(0===l)return this.bitb=n,this.bitk=o,t.avail_in=l,t.total_in+=s-t.next_in_index,t.next_in_index=s,this.write=d,this.inflate_flush(t,i);i=0,l--,n|=(255&t.next_in[s++])<<o,o+=8}if(a=g[3*(p[0]+(n&inflate_mask[a]))+1],f=g[3*(p[0]+(n&inflate_mask[a]))+2],f<16)n>>>=a,o-=a,S[b++]=f;else{for(_=18===f?7:f-14,h=18===f?11:3;o<a+_;){if(0===l)return this.bitb=n,this.bitk=o,t.avail_in=l,t.total_in+=s-t.next_in_index,t.next_in_index=s,this.write=d,this.inflate_flush(t,i);i=0,l--,n|=(255&t.next_in[s++])<<o,o+=8}if(n>>>=a,o-=a,h+=n&inflate_mask[_],n>>>=_,o-=_,_=b,a=m,_+h>258+(31&a)+(a>>5&31)||16===f&&_<1)return this.mode=9,t.msg="invalid bit length repeat",i=-3,this.bitb=n,this.bitk=o,t.avail_in=l,t.total_in+=s-t.next_in_index,t.next_in_index=s,this.write=d,this.inflate_flush(t,i);f=16===f?S[_-1]:0;do{S[_++]=f}while(0!=--h);b=_}}p[0]=-1;const C=[9],R=[6],E=[0],k=[0];if(a=inflate_trees_dynamic(257+(31&a),1+(a>>5&31),S,C,R,E,k,g,t),0!==a)return-3===a&&(this.mode=9),i=a,this.bitb=n,this.bitk=o,t.avail_in=l,t.total_in+=s-t.next_in_index,t.next_in_index=s,this.write=d,this.inflate_flush(t,i);y.init(C[0],R[0],g,E[0],g,k[0]),this.mode=6;case 6:if(this.bitb=n,this.bitk=o,t.avail_in=l,t.total_in+=s-t.next_in_index,t.next_in_index=s,this.write=d,1!==(i=y.proc(this,t,i)))return this.inflate_flush(t,i);if(i=0,s=t.next_in_index,l=t.avail_in,n=this.bitb,o=this.bitk,d=this.write,h=d<this.read?this.read-d-1:this.end-d,0===this.last){this.mode=0;break}this.mode=7;case 7:if(this.write=d,i=this.inflate_flush(t,i),d=this.write,h=d<this.read?this.read-d-1:this.end-d,this.read!==this.write)return this.bitb=n,this.bitk=o,t.avail_in=l,t.total_in+=s-t.next_in_index,t.next_in_index=s,this.write=d,this.inflate_flush(t,i);this.mode=8;case 8:return i=1,this.bitb=n,this.bitk=o,t.avail_in=l,t.total_in+=s-t.next_in_index,t.next_in_index=s,this.write=d,this.inflate_flush(t,i);case 9:return i=-3,this.bitb=n,this.bitk=o,t.avail_in=l,t.total_in+=s-t.next_in_index,t.next_in_index=s,this.write=d,this.inflate_flush(t,i);default:return i=-2,this.bitb=n,this.bitk=o,t.avail_in=l,t.total_in+=s-t.next_in_index,t.next_in_index=s,this.write=d,this.inflate_flush(t,i)}}set_dictionary(t,i,a){this.window.set(t.subarray(i,i+a),0),this.read=this.write=a}}class Inflate{constructor(t){this.isGZip=!1,this.method=0,this.gflags=0,this.name="",this.mtime=0,this.xlen=0,this.dictChecksum=0,this.fullChecksum=0,this.inflatedSize=0,this.wbits=0,this.wbits=15,this.blocks=new InfBlocks(1<<this.wbits),this.mode=t?22:0}get isComplete(){const{blocks:t}=this,i=(0===t.mode||8===t.mode)&&0===t.bitb&&0===t.bitk;return 31===this.mode&&i}get fileName(){return this.name}get modDate(){if(0!==this.mtime)return new Date(1e3*this.mtime)}get checksum(){return this.fullChecksum}get fullSize(){return this.inflatedSize}get containerFormat(){return this.isGZip?2:0===this.method?0:1}inflate(t){let i;if(!t||!t.next_in)return-2;let a=-5;for(;;)switch(this.mode){case 0:if(0===t.avail_in)return a;if(i=t.next_in[t.next_in_index],i!==GZIP_ID1){this.mode=2;break}this.mode=1,a=0,t.avail_in--,t.total_in++,t.next_in_index++;case 1:if(0===t.avail_in)return a;if(a=0,t.avail_in--,t.total_in++,i=t.next_in[t.next_in_index++],i!==GZIP_ID2){this.mode=32,t.msg="invalid gzip id";break}this.isGZip=!0,this.mode=2;case 2:if(0===t.avail_in)return a;if(a=0,t.avail_in--,t.total_in++,this.method=t.next_in[t.next_in_index++],(15&this.method)!==Z_DEFLATED){this.mode=32,t.msg="unknown compression method";break}if(8+(this.method>>4)>this.wbits){this.mode=32,t.msg="invalid window size";break}this.mode=3;case 3:if(0===t.avail_in)return a;if(a=0,t.avail_in--,t.total_in++,i=255&t.next_in[t.next_in_index++],this.isGZip){this.gflags=i,this.mode=9;break}if(((this.method<<8)+i)%31!=0){this.mode=32,t.msg="incorrect header check";break}if(0==(i&PRESET_DICT)){this.mode=22;break}this.mode=4;case 4:if(0===t.avail_in)return a;a=0,t.avail_in--,t.total_in++,this.dictChecksum=(255&t.next_in[t.next_in_index++])<<24&4278190080,this.mode=5;case 5:if(0===t.avail_in)return a;a=0,t.avail_in--,t.total_in++,this.dictChecksum|=(255&t.next_in[t.next_in_index++])<<16&16711680,this.mode=6;case 6:if(0===t.avail_in)return a;a=0,t.avail_in--,t.total_in++,this.dictChecksum|=(255&t.next_in[t.next_in_index++])<<8&65280,this.mode=7;case 7:return 0===t.avail_in?a:(a=0,t.avail_in--,t.total_in++,this.dictChecksum|=255&t.next_in[t.next_in_index++],this.mode=8,2);case 8:return this.mode=32,t.msg="need dictionary",-2;case 9:case 10:case 11:case 12:if(0===t.avail_in)return a;if(a=0,t.avail_in--,t.total_in++,i=255&t.next_in[t.next_in_index++],this.mtime=this.mtime>>>8|i<<24,12!==this.mode){this.mode++;break}this.mode=13;case 13:case 14:case 20:case 21:if(0===t.avail_in)return a;a=0,t.avail_in--,t.total_in++,t.next_in_index++,14===this.mode?4&this.gflags?this.mode=15:8&this.gflags?this.mode=18:16&this.gflags?this.mode=19:2&this.gflags?this.mode=20:this.mode=22:this.mode++;break;case 15:case 16:if(0===t.avail_in)return a;if(a=0,t.avail_in--,t.total_in++,i=255&t.next_in[t.next_in_index++],this.xlen=this.xlen>>>8|i<<24,15===this.mode)break;this.xlen=this.xlen>>>16;case 17:if(0===t.avail_in)return a;a=0,t.avail_in--,t.total_in++,t.next_in_index++,this.xlen--,0===this.xlen&&(8&this.gflags?this.mode=18:16&this.gflags?this.mode=19:2&this.gflags?this.mode=20:this.mode=22);break;case 18:case 19:if(0===t.avail_in)return a;a=0,t.avail_in--,t.total_in++,i=255&t.next_in[t.next_in_index++],0!==i?18===this.mode&&(this.name+=String.fromCharCode(i)):19!==this.mode&&16&this.gflags?this.mode=19:2&this.gflags?this.mode=20:this.mode=22;break;case 22:if(a=this.blocks.proc(t,a),-3===a){this.mode=32;break}if(1!==a)return a;if(a=0,this.blocks.reset(),0===this.method){this.mode=31;break}this.mode=23;case 23:case 24:case 25:case 26:if(0===t.avail_in)return a;a=0,t.avail_in--,t.total_in++,i=255&t.next_in[t.next_in_index++],this.isGZip?this.fullChecksum=this.fullChecksum>>>8|i<<24:this.fullChecksum=this.fullChecksum<<8|i,this.mode++,27!==this.mode||this.isGZip||(this.mode=31);break;case 27:case 28:case 29:case 30:if(0===t.avail_in)return a;a=0,t.avail_in--,t.total_in++,i=255&t.next_in[t.next_in_index++],this.inflatedSize=this.inflatedSize>>>8|i<<24,this.mode++;break;case 31:return 1;case 32:return-3;default:return-2}}inflateSetDictionary(t){if(8!==this.mode)return-2;const i=u8ArrayFromBufferSource(t);if(!i)return-3;let a=0,n=i.byteLength;n>=1<<this.wbits&&(n=(1<<this.wbits)-1,a=i.byteLength-n);return adler32(i)!==this.dictChecksum?-3:(this.blocks.set_dictionary(i,a,n),this.mode=22,0)}}class Inflater{constructor(t){const i=null==t?void 0:t.raw;if(void 0!==i&&!0!==i&&!1!==i)throw new TypeError("options.raw must be undefined or true or false");const a=void 0!==i&&i,n=null==t?void 0:t.dictionary;if(void 0!==n){if(a)throw new RangeError("options.dictionary cannot be set when options.raw is true");if(void 0===u8ArrayFromBufferSource(n))throw new TypeError("options.dictionary must be undefined or a buffer or a buffer view");this.customDict=n}this.inflate=new Inflate(a),this.z=new ZStream}append(t){const i=u8ArrayFromBufferSource(t);if(!(i instanceof Uint8Array))throw new TypeError("data must be an ArrayBuffer or buffer view");if(0===i.length)return[];const{inflate:a,z:n}=this,o=[];let s=!1;n.append(i);do{n.next_out_index=0,n.avail_out=OUTPUT_BUFSIZE,0!==n.avail_in||s||(n.next_in_index=0,s=!0);const t=a.inflate(n);if(s&&-5===t){if(0!==n.avail_in)throw new Error("inflate error: bad input")}else if(2===t){if(!this.customDict)throw new Error("Custom dictionary required for this data");if(0!==a.inflateSetDictionary(this.customDict))throw new Error("Custom dictionary is not valid for this data")}else if(0!==t&&1!==t)throw new Error("inflate error: "+n.msg);if((s||1===t)&&n.avail_in===i.length)throw new Error("inflate error: bad input data");if(n.next_out_index){const t=new Uint8Array(n.next_out.subarray(0,n.next_out_index)),i=2===a.containerFormat;void 0===this.checksum&&(this.checksum=i?0:1),this.checksum=i?crc32(t,this.checksum):adler32(t,this.checksum),o.push(t)}}while(n.avail_in>0||0===n.avail_out);return o}finish(){const t=this.inflate.checksum,i=this.inflate.fullSize,a=this.inflate.isComplete,n=0===t?"unchecked":t===this.checksum?"match":"mismatch",o=0===i?"unchecked":i===this.z.total_out?"match":"mismatch";return{success:a&&"mismatch"!==n&&"mismatch"!==o,complete:a,checksum:n,fileSize:o,fileName:this.inflate.fileName,modDate:this.inflate.modDate}}}const D_CODES=30,BL_CODES=19,LENGTH_CODES=29,LITERALS=256,L_CODES=LITERALS+1+LENGTH_CODES,HEAP_SIZE=2*L_CODES+1,MAX_BL_BITS=7,_dist_code=[0,1,2,3,4,4,5,5,6,6,6,6,7,7,7,7,8,8,8,8,8,8,8,8,9,9,9,9,9,9,9,9,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,0,0,16,17,18,18,19,19,20,20,20,20,21,21,21,21,22,22,22,22,22,22,22,22,23,23,23,23,23,23,23,23,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29];class Tree{constructor(t,i){this.dyn_tree=t,this.stat_desc=i,this.max_code=0}gen_bitlen(t){var i,a,n,o,s,l,d=this.dyn_tree,h=this.stat_desc.static_tree,_=this.stat_desc.extra_bits,f=this.stat_desc.extra_base,m=this.stat_desc.max_length,b=0;for(o=0;o<=15;o++)t.bl_count[o]=0;for(d[2*t.heap[t.heap_max]+1]=0,i=t.heap_max+1;i<HEAP_SIZE;i++)(o=d[2*d[2*(a=t.heap[i])+1]+1]+1)>m&&(o=m,b++),d[2*a+1]=o,a>this.max_code||(t.bl_count[o]++,s=0,a>=f&&(s=_[a-f]),l=d[2*a],t.opt_len+=l*(o+s),h&&(t.static_len+=l*(h[2*a+1]+s)));if(0!==b){do{for(o=m-1;0===t.bl_count[o];)o--;t.bl_count[o]--,t.bl_count[o+1]+=2,t.bl_count[m]--,b-=2}while(b>0);for(o=m;0!==o;o--)for(a=t.bl_count[o];0!==a;)(n=t.heap[--i])>this.max_code||(d[2*n+1]!=o&&(t.opt_len+=(o-d[2*n+1])*d[2*n],d[2*n+1]=o),a--)}}bi_reverse(t,i){let a=0;do{a|=1&t,t>>>=1,a<<=1}while(--i>0);return a>>>1}gen_codes(t,i,a){const n=new Uint16Array(16);let o=0;for(let s=1;s<=15;s++)n[s]=o=o+a[s-1]<<1;for(let s=0;s<=i;s++){const i=t[2*s+1];0!==i&&(t[2*s]=this.bi_reverse(n[i]++,i))}}build_tree(t){var i,a,n,o=this.dyn_tree,s=this.stat_desc.static_tree,l=this.stat_desc.elems,d=-1;for(t.heap_len=0,t.heap_max=HEAP_SIZE,i=0;i<l;i++)0!==o[2*i]?(t.heap[++t.heap_len]=d=i,t.depth[i]=0):o[2*i+1]=0;for(;t.heap_len<2;)o[2*(n=t.heap[++t.heap_len]=d<2?++d:0)]=1,t.depth[n]=0,t.opt_len--,s&&(t.static_len-=s[2*n+1]);for(this.max_code=d,i=Math.floor(t.heap_len/2);i>=1;i--)t.pqdownheap(o,i);n=l;do{i=t.heap[1],t.heap[1]=t.heap[t.heap_len--],t.pqdownheap(o,1),a=t.heap[1],t.heap[--t.heap_max]=i,t.heap[--t.heap_max]=a,o[2*n]=o[2*i]+o[2*a],t.depth[n]=Math.max(t.depth[i],t.depth[a])+1,o[2*i+1]=o[2*a+1]=n,t.heap[1]=n++,t.pqdownheap(o,1)}while(t.heap_len>=2);t.heap[--t.heap_max]=t.heap[1],this.gen_bitlen(t),this.gen_codes(o,this.max_code,t.bl_count)}static d_code(t){return t<256?_dist_code[t]:_dist_code[256+(t>>>7)]}}Tree._length_code=[0,1,2,3,4,5,6,7,8,8,9,9,10,10,11,11,12,12,12,12,13,13,13,13,14,14,14,14,15,15,15,15,16,16,16,16,16,16,16,16,17,17,17,17,17,17,17,17,18,18,18,18,18,18,18,18,19,19,19,19,19,19,19,19,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,28],Tree.base_length=[0,1,2,3,4,5,6,7,8,10,12,14,16,20,24,28,32,40,48,56,64,80,96,112,128,160,192,224,0],Tree.base_dist=[0,1,2,3,4,6,8,12,16,24,32,48,64,96,128,192,256,384,512,768,1024,1536,2048,3072,4096,6144,8192,12288,16384,24576],Tree.extra_lbits=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],Tree.extra_dbits=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],Tree.extra_blbits=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],Tree.bl_order=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];class StaticTree{constructor(t,i,a,n,o){this.static_tree=t,this.extra_bits=i,this.extra_base=a,this.elems=n,this.max_length=o}}StaticTree.static_ltree=new Uint16Array([12,8,140,8,76,8,204,8,44,8,172,8,108,8,236,8,28,8,156,8,92,8,220,8,60,8,188,8,124,8,252,8,2,8,130,8,66,8,194,8,34,8,162,8,98,8,226,8,18,8,146,8,82,8,210,8,50,8,178,8,114,8,242,8,10,8,138,8,74,8,202,8,42,8,170,8,106,8,234,8,26,8,154,8,90,8,218,8,58,8,186,8,122,8,250,8,6,8,134,8,70,8,198,8,38,8,166,8,102,8,230,8,22,8,150,8,86,8,214,8,54,8,182,8,118,8,246,8,14,8,142,8,78,8,206,8,46,8,174,8,110,8,238,8,30,8,158,8,94,8,222,8,62,8,190,8,126,8,254,8,1,8,129,8,65,8,193,8,33,8,161,8,97,8,225,8,17,8,145,8,81,8,209,8,49,8,177,8,113,8,241,8,9,8,137,8,73,8,201,8,41,8,169,8,105,8,233,8,25,8,153,8,89,8,217,8,57,8,185,8,121,8,249,8,5,8,133,8,69,8,197,8,37,8,165,8,101,8,229,8,21,8,149,8,85,8,213,8,53,8,181,8,117,8,245,8,13,8,141,8,77,8,205,8,45,8,173,8,109,8,237,8,29,8,157,8,93,8,221,8,61,8,189,8,125,8,253,8,19,9,275,9,147,9,403,9,83,9,339,9,211,9,467,9,51,9,307,9,179,9,435,9,115,9,371,9,243,9,499,9,11,9,267,9,139,9,395,9,75,9,331,9,203,9,459,9,43,9,299,9,171,9,427,9,107,9,363,9,235,9,491,9,27,9,283,9,155,9,411,9,91,9,347,9,219,9,475,9,59,9,315,9,187,9,443,9,123,9,379,9,251,9,507,9,7,9,263,9,135,9,391,9,71,9,327,9,199,9,455,9,39,9,295,9,167,9,423,9,103,9,359,9,231,9,487,9,23,9,279,9,151,9,407,9,87,9,343,9,215,9,471,9,55,9,311,9,183,9,439,9,119,9,375,9,247,9,503,9,15,9,271,9,143,9,399,9,79,9,335,9,207,9,463,9,47,9,303,9,175,9,431,9,111,9,367,9,239,9,495,9,31,9,287,9,159,9,415,9,95,9,351,9,223,9,479,9,63,9,319,9,191,9,447,9,127,9,383,9,255,9,511,9,0,7,64,7,32,7,96,7,16,7,80,7,48,7,112,7,8,7,72,7,40,7,104,7,24,7,88,7,56,7,120,7,4,7,68,7,36,7,100,7,20,7,84,7,52,7,116,7,3,8,131,8,67,8,195,8,35,8,163,8,99,8,227,8]),StaticTree.static_dtree=new Uint16Array([0,5,16,5,8,5,24,5,4,5,20,5,12,5,28,5,2,5,18,5,10,5,26,5,6,5,22,5,14,5,30,5,1,5,17,5,9,5,25,5,5,5,21,5,13,5,29,5,3,5,19,5,11,5,27,5,7,5,23,5]),StaticTree.static_l_desc=new StaticTree(StaticTree.static_ltree,Tree.extra_lbits,LITERALS+1,L_CODES,15),StaticTree.static_d_desc=new StaticTree(StaticTree.static_dtree,Tree.extra_dbits,0,D_CODES,15),StaticTree.static_bl_desc=new StaticTree(null,Tree.extra_blbits,0,BL_CODES,MAX_BL_BITS);const makeConfig=(t,i,a,n,o)=>({good_length:t,max_lazy:i,nice_length:a,max_chain:n,func:o}),config_table=[makeConfig(0,0,0,0,0),makeConfig(4,4,8,4,1),makeConfig(4,5,16,8,1),makeConfig(4,6,32,32,1),makeConfig(4,4,16,16,2),makeConfig(8,16,32,32,2),makeConfig(8,16,128,128,2),makeConfig(8,32,128,256,2),makeConfig(32,128,258,1024,2),makeConfig(32,258,258,4096,2)];function smaller(t,i,a,n){const o=t[2*i],s=t[2*a];return o<s||o==s&&n[i]<=n[a]}const END_BLOCK=256,REP_3_6=16,REPZ_3_10=17,REPZ_11_138=18,STORED_BLOCK=0,STATIC_TREES=1,DYN_TREES=2,MIN_MATCH=3,MAX_MATCH=258,MIN_LOOKAHEAD=MAX_MATCH+MIN_MATCH+1,hash_bits=15,hash_size=1<<hash_bits,hash_mask=hash_size-1,hash_shift=Math.floor((hash_bits+MIN_MATCH-1)/MIN_MATCH),lit_bufsize=16384,pending_buf_size=4*lit_bufsize,d_buf=Math.floor(lit_bufsize/2),l_buf=3*lit_bufsize,window_size=65536;class Deflate{constructor(t,i=6,a=0){if(this.status=1,this.pending_buf=new Uint8Array(pending_buf_size),this.pending=0,this.pending_out=0,this.last_flush=0,this.window=new Uint8Array(window_size),this.prev=new Uint16Array(32768),this.head=new Uint16Array(hash_size),this.ins_h=0,this.block_start=0,this.match_length=MIN_MATCH-1,this.match_available=!1,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=MIN_MATCH-1,this.dyn_ltree=new Uint16Array(2*HEAP_SIZE),this.dyn_dtree=new Uint16Array(2*(2*D_CODES+1)),this.bl_tree=new Uint16Array(2*(2*BL_CODES+1)),this.l_desc=new Tree(this.dyn_ltree,StaticTree.static_l_desc),this.d_desc=new Tree(this.dyn_dtree,StaticTree.static_d_desc),this.bl_desc=new Tree(this.bl_tree,StaticTree.static_bl_desc),this.depth=new Uint16Array(2*L_CODES+1),this.last_lit=0,this.matches=0,this.opt_len=0,this.static_len=0,this.last_eob_len=8,this.bi_buf=0,this.bi_valid=0,this.bl_count=new Uint16Array(16),this.heap=new Uint16Array(2*L_CODES+1),this.heap_len=0,this.heap_max=HEAP_SIZE,i<0||i>9||a<0||a>2)throw RangeError("level or strategy is out of range");this.strm=t,this.level=i,this.strategy=a,t.msg="",t.total_in=t.total_out=0,this.init_block();for(let n=0;n<hash_size;++n)this.head[n]=0;this.max_lazy_match=config_table[i].max_lazy,this.good_match=config_table[i].good_length,this.nice_match=config_table[i].nice_length,this.max_chain_length=config_table[i].max_chain}init_block(){for(let t=0;t<L_CODES;t++)this.dyn_ltree[2*t]=0;for(let t=0;t<D_CODES;t++)this.dyn_dtree[2*t]=0;for(let t=0;t<BL_CODES;t++)this.bl_tree[2*t]=0;this.dyn_ltree[2*END_BLOCK]=1,this.opt_len=this.static_len=0,this.last_lit=this.matches=0}pqdownheap(t,i){const a=this.heap,n=a[i];let o=i<<1;for(;o<=this.heap_len&&(o<this.heap_len&&smaller(t,a[o+1],a[o],this.depth)&&o++,!smaller(t,n,a[o],this.depth));)a[i]=a[o],i=o,o<<=1;a[i]=n}scan_tree(t,i){var a,n=-1,o=t[1],s=0,l=7,d=4;0===o&&(l=138,d=3),t[2*(i+1)+1]=65535;for(let h=0;h<=i;h++)a=o,o=t[2*(h+1)+1],++s<l&&a==o||(s<d?this.bl_tree[2*a]+=s:0!==a?(a!=n&&this.bl_tree[2*a]++,this.bl_tree[2*REP_3_6]++):s<=10?this.bl_tree[2*REPZ_3_10]++:this.bl_tree[2*REPZ_11_138]++,s=0,n=a,0===o?(l=138,d=3):a==o?(l=6,d=3):(l=7,d=4))}build_bl_tree(){let t;for(this.scan_tree(this.dyn_ltree,this.l_desc.max_code),this.scan_tree(this.dyn_dtree,this.d_desc.max_code),this.bl_desc.build_tree(this),t=BL_CODES-1;t>=3&&0===this.bl_tree[2*Tree.bl_order[t]+1];t--);return this.opt_len+=3*(t+1)+5+5+4,t}put_short(t){this.pending_buf[this.pending++]=255&t,this.pending_buf[this.pending++]=t>>>8&255}send_bits(t,i){if(this.bi_valid>16-i){this.bi_buf|=t<<this.bi_valid&65535;const a=this.pending;this.pending_buf[a]=this.bi_buf,this.pending_buf[a+1]=this.bi_buf>>>8,this.pending=a+2,this.bi_buf=t>>>16-this.bi_valid,this.bi_valid+=i-16}else this.bi_buf|=t<<this.bi_valid&65535,this.bi_valid+=i}send_code(t,i){const a=2*t;this.send_bits(65535&i[a],65535&i[a+1])}send_tree(t,i){var a,n=-1,o=t[1],s=0,l=7,d=4;0===o&&(l=138,d=3);for(let h=0;h<=i;h++)if(a=o,o=t[2*(h+1)+1],!(++s<l&&a==o)){if(s<d)do{this.send_code(a,this.bl_tree)}while(0!=--s);else 0!==a?(a!=n&&(this.send_code(a,this.bl_tree),s--),this.send_code(REP_3_6,this.bl_tree),this.send_bits(s-3,2)):s<=10?(this.send_code(REPZ_3_10,this.bl_tree),this.send_bits(s-3,3)):(this.send_code(REPZ_11_138,this.bl_tree),this.send_bits(s-11,7));s=0,n=a,0===o?(l=138,d=3):a==o?(l=6,d=3):(l=7,d=4)}}send_all_trees(t,i,a){this.send_bits(t-257,5),this.send_bits(i-1,5),this.send_bits(a-4,4);for(let n=0;n<a;n++)this.send_bits(this.bl_tree[2*Tree.bl_order[n]+1],3);this.send_tree(this.dyn_ltree,t-1),this.send_tree(this.dyn_dtree,i-1)}bi_flush(){16===this.bi_valid?(this.put_short(this.bi_buf),this.bi_buf=0,this.bi_valid=0):this.bi_valid>=8&&(this.pending_buf[this.pending++]=this.bi_buf,this.bi_buf>>>=8,this.bi_valid-=8)}_tr_align(){this.send_bits(STATIC_TREES<<1,3),this.send_code(END_BLOCK,StaticTree.static_ltree),this.bi_flush(),1+this.last_eob_len+10-this.bi_valid<9&&(this.send_bits(STATIC_TREES<<1,3),this.send_code(END_BLOCK,StaticTree.static_ltree),this.bi_flush()),this.last_eob_len=7}_tr_tally(t,i){if(this.pending_buf[d_buf+2*this.last_lit]=t>>>8&255,this.pending_buf[d_buf+2*this.last_lit+1]=255&t,this.pending_buf[l_buf+this.last_lit]=255&i,this.last_lit++,0===t?this.dyn_ltree[2*i]++:(this.matches++,t--,this.dyn_ltree[2*(Tree._length_code[i]+LITERALS+1)]++,this.dyn_dtree[2*Tree.d_code(t)]++),0==(8191&this.last_lit)&&this.level>2){let t=8*this.last_lit,i=this.strstart-this.block_start;for(let a=0;a<D_CODES;a++)t+=this.dyn_dtree[2*a]*(5+Tree.extra_dbits[a]);if(t>>>=3,this.matches<Math.floor(this.last_lit/2)&&t<Math.floor(i/2))return!0}return this.last_lit===lit_bufsize-1}compress_block(t,i){let a=0;if(0!==this.last_lit)do{let n=this.pending_buf[d_buf+2*a]<<8&65280|255&this.pending_buf[d_buf+2*a+1],o=255&this.pending_buf[l_buf+a];if(a++,0===n)this.send_code(o,t);else{let a=Tree._length_code[o];this.send_code(a+LITERALS+1,t);let s=Tree.extra_lbits[a];0!==s&&(o-=Tree.base_length[a],this.send_bits(o,s)),n--,a=Tree.d_code(n),this.send_code(a,i),s=Tree.extra_dbits[a],0!==s&&(n-=Tree.base_dist[a],this.send_bits(n,s))}}while(a<this.last_lit);this.send_code(END_BLOCK,t),this.last_eob_len=t[2*END_BLOCK+1]}bi_windup(){this.bi_valid>8?this.put_short(this.bi_buf):this.bi_valid>0&&(this.pending_buf[this.pending++]=this.bi_buf),this.bi_buf=0,this.bi_valid=0}copy_block(t,i,a){this.bi_windup(),this.last_eob_len=8,a&&(this.put_short(i),this.put_short(~i)),this.pending_buf.set(this.window.subarray(t,t+i),this.pending),this.pending+=i}_tr_stored_block(t,i,a){this.send_bits((STORED_BLOCK<<1)+(a?1:0),3),this.copy_block(t,i,!0)}_tr_flush_block(t,i,a){let n,o,s=0;this.level>0?(this.l_desc.build_tree(this),this.d_desc.build_tree(this),s=this.build_bl_tree(),n=this.opt_len+3+7>>>3,o=this.static_len+3+7>>>3,o<=n&&(n=o)):n=o=i+5,i+4<=n&&-1!==t?this._tr_stored_block(t,i,a):o==n?(this.send_bits((STATIC_TREES<<1)+(a?1:0),3),this.compress_block(StaticTree.static_ltree,StaticTree.static_dtree)):(this.send_bits((DYN_TREES<<1)+(a?1:0),3),this.send_all_trees(this.l_desc.max_code+1,this.d_desc.max_code+1,s+1),this.compress_block(this.dyn_ltree,this.dyn_dtree)),this.init_block(),a&&this.bi_windup()}flush_block_only(t){this._tr_flush_block(this.block_start>=0?this.block_start:-1,this.strstart-this.block_start,t),this.block_start=this.strstart,this.strm.flush_pending(this)}fill_window(){do{let t=window_size-this.lookahead-this.strstart;if(0===t&&0===this.strstart&&0===this.lookahead)t=32768;else if(-1===t)t--;else if(this.strstart>=65536-MIN_LOOKAHEAD){this.window.set(this.window.subarray(32768,65536),0),this.match_start-=32768,this.strstart-=32768,this.block_start-=32768;let i=hash_size,a=i;do{let t=65535&this.head[--a];this.head[a]=t>=32768?t-32768:0}while(0!=--i);i=32768,a=i;do{let t=65535&this.prev[--a];this.prev[a]=t>=32768?t-32768:0}while(0!=--i);t+=32768}if(0===this.strm.avail_in)return;const i=this.strm.read_into_buf(this.window,this.strstart+this.lookahead,t);this.lookahead+=i,this.lookahead>=MIN_MATCH&&(this.ins_h=255&this.window[this.strstart],this.ins_h=(this.ins_h<<hash_shift^255&this.window[this.strstart+1])&hash_mask)}while(this.lookahead<MIN_LOOKAHEAD&&0!==this.strm.avail_in)}deflate_stored(t){let i=65535;for(i>pending_buf_size-5&&(i=pending_buf_size-5);;){if(this.lookahead<=1){if(this.fill_window(),0===this.lookahead&&0===t)return 0;if(0===this.lookahead)break}this.strstart+=this.lookahead,this.lookahead=0;let a=this.block_start+i;if((0===this.strstart||this.strstart>=a)&&(this.lookahead=this.strstart-a,this.strstart=a,this.flush_block_only(!1),0===this.strm.avail_out))return 0;if(this.strstart-this.block_start>=32768-MIN_LOOKAHEAD&&(this.flush_block_only(!1),0===this.strm.avail_out))return 0}return this.flush_block_only(4===t),0===this.strm.avail_out?4===t?2:0:4===t?3:1}longest_match(t){let i=this.max_chain_length,a=this.strstart,n=this.prev_length,o=this.strstart>32768-MIN_LOOKAHEAD?this.strstart-(32768-MIN_LOOKAHEAD):0,s=this.nice_match;const l=this.window,d=this.strstart+MAX_MATCH;let h=l[a+n-1],_=l[a+n];const f=l[a],m=l[a+1];this.prev_length>=this.good_match&&(i>>=2),s>this.lookahead&&(s=this.lookahead);do{let b=t,S=!0;for(;;){if(b=t,l[b+n]!==_||l[b+n-1]!==h){if((t=this.prev[32767&t])>o&&0!=--i)continue;S=!1}break}if(!S)break;if(l[b]!==f||l[b+1]!==m)continue;a+=2,b+=2;do{const t=(l[a]<<24|l[a+1]<<16|l[a+2]<<8|l[a+3])^(l[b]<<24|l[b+1]<<16|l[b+2]<<8|l[b+3]);if(t){const i=Math.clz32(t)>>3;a+=i,b+=i;break}a+=4,b+=4}while(a<d);a>d&&(a=d);let w=MAX_MATCH-(d-a);if(a=d-MAX_MATCH,w>n){if(this.match_start=t,n=w,w>=s)break;h=l[a+n-1],_=l[a+n]}}while((t=this.prev[32767&t])>o&&0!=--i);return n<=this.lookahead?n:this.lookahead}deflate_fast(t){let i,a=0;for(;;){if(this.lookahead<MIN_LOOKAHEAD){if(this.fill_window(),this.lookahead<MIN_LOOKAHEAD&&0===t)return 0;if(0===this.lookahead)break}if(this.lookahead>=MIN_MATCH&&(this.ins_h=(this.ins_h<<hash_shift^255&this.window[this.strstart+(MIN_MATCH-1)])&hash_mask,a=65535&this.head[this.ins_h],this.prev[32767&this.strstart]=this.head[this.ins_h],this.head[this.ins_h]=this.strstart),0!==a&&(this.strstart-a&65535)<=32768-MIN_LOOKAHEAD&&2!==this.strategy&&(this.match_length=this.longest_match(a)),this.match_length>=MIN_MATCH)if(i=this._tr_tally(this.strstart-this.match_start,this.match_length-MIN_MATCH),this.lookahead-=this.match_length,this.match_length<=this.max_lazy_match&&this.lookahead>=MIN_MATCH){this.match_length--;do{this.strstart++,this.ins_h=(this.ins_h<<hash_shift^255&this.window[this.strstart+(MIN_MATCH-1)])&hash_mask,a=65535&this.head[this.ins_h],this.prev[32767&this.strstart]=this.head[this.ins_h],this.head[this.ins_h]=this.strstart}while(0!=--this.match_length);this.strstart++}else this.strstart+=this.match_length,this.match_length=0,this.ins_h=255&this.window[this.strstart],this.ins_h=(this.ins_h<<hash_shift^255&this.window[this.strstart+1])&hash_mask;else i=this._tr_tally(0,255&this.window[this.strstart]),this.lookahead--,this.strstart++;if(i&&(this.flush_block_only(!1),0===this.strm.avail_out))return 0}return this.flush_block_only(4===t),0===this.strm.avail_out?4===t?2:0:4===t?3:1}deflate_slow(t){let i,a,n,o=0;for(;;){if(this.lookahead<MIN_LOOKAHEAD){if(this.fill_window(),this.lookahead<MIN_LOOKAHEAD&&0===t)return 0;if(0===this.lookahead)break}if(this.lookahead>=MIN_MATCH&&(this.ins_h=(this.ins_h<<hash_shift^255&this.window[this.strstart+(MIN_MATCH-1)])&hash_mask,o=65535&this.head[this.ins_h],this.prev[32767&this.strstart]=this.head[this.ins_h],this.head[this.ins_h]=this.strstart),this.prev_length=this.match_length,n=this.match_start,this.match_length=MIN_MATCH-1,0!==o&&this.prev_length<this.max_lazy_match&&(this.strstart-o&65535)<=32768-MIN_LOOKAHEAD&&(2!==this.strategy&&(this.match_length=this.longest_match(o)),this.match_length<=5&&(1===this.strategy||this.match_length===MIN_MATCH&&this.strstart-this.match_start>4096)&&(this.match_length=MIN_MATCH-1)),this.prev_length>=MIN_MATCH&&this.match_length<=this.prev_length){a=this.strstart+this.lookahead-MIN_MATCH,i=this._tr_tally(this.strstart-1-n,this.prev_length-MIN_MATCH),this.lookahead-=this.prev_length-1,this.prev_length-=2;do{++this.strstart<=a&&(this.ins_h=(this.ins_h<<hash_shift^255&this.window[this.strstart+(MIN_MATCH-1)])&hash_mask,o=65535&this.head[this.ins_h],this.prev[32767&this.strstart]=this.head[this.ins_h],this.head[this.ins_h]=this.strstart)}while(0!=--this.prev_length);if(this.match_available=!1,this.match_length=MIN_MATCH-1,this.strstart++,i&&(this.flush_block_only(!1),0===this.strm.avail_out))return 0}else if(this.match_available){if(i=this._tr_tally(0,255&this.window[this.strstart-1]),i&&this.flush_block_only(!1),this.strstart++,this.lookahead--,0===this.strm.avail_out)return 0}else this.match_available=!0,this.strstart++,this.lookahead--}return this.match_available&&(i=this._tr_tally(0,255&this.window[this.strstart-1]),this.match_available=!1),this.flush_block_only(4===t),0===this.strm.avail_out?4===t?2:0:4===t?3:1}deflateSetDictionary(t){const i=t.byteLength;let a,n=i,o=0;if(!t||1!==this.status)return-2;if(n<MIN_MATCH)return 0;for(n>32768-MIN_LOOKAHEAD&&(n=32768-MIN_LOOKAHEAD,o=i-n),this.window.set(t.subarray(o,o+n),0),this.strstart=n,this.block_start=n,this.ins_h=255&this.window[0],this.ins_h=(this.ins_h<<hash_shift^255&this.window[1])&hash_mask,a=0;a<=n-MIN_MATCH;a++)this.ins_h=(this.ins_h<<hash_shift^255&this.window[a+(MIN_MATCH-1)])&hash_mask,this.prev[32767&a]=this.head[this.ins_h],this.head[this.ins_h]=a;return 0}deflate(t){if(t>4||t<0)return-2;const{strm:i}=this;if(!i.next_out||!i.next_in&&0!==i.avail_in||3===this.status&&4!=t)return-2;if(0===i.avail_out)return-5;let a=this.last_flush;if(this.last_flush=t,1===this.status&&(this.status=2),0!==this.pending){if(i.flush_pending(this),0===i.avail_out)return this.last_flush=-1,0}else if(0===i.avail_in&&t<=a&&4!==t)return-5;if(3===this.status&&0!==i.avail_in)return-5;if(0!==i.avail_in||0!==this.lookahead||0!==t&&3!==this.status){let a;switch(config_table[this.level].func){case 0:a=this.deflate_stored(t);break;case 1:a=this.deflate_fast(t);break;case 2:default:a=this.deflate_slow(t)}if(2!=a&&3!==a||(this.status=3),0===a||2===a)return 0===i.avail_out&&(this.last_flush=-1),0;if(1===a){if(1===t)this._tr_align();else if(this._tr_stored_block(0,0,!1),3===t)for(let t=0;t<hash_size;t++)this.head[t]=0;if(i.flush_pending(this),0===i.avail_out)return this.last_flush=-1,0}}return 4!==t?0:1}}class Deflater{constructor(t){var i,a;this.checksum=1,this.origSize=0,this.dictChecksum=0;const n=null!==(i=null==t?void 0:t.level)&&void 0!==i?i:6,o=null!==(a=null==t?void 0:t.format)&&void 0!==a?a:"deflate",s=null==t?void 0:t.dictionary,l=null==t?void 0:t.fileName;if("number"!=typeof n||n<1||n>9)throw new RangeError("level must be between 1 and 9, inclusive");if("gzip"!==o&&"raw"!==o&&"deflate"!==o)throw new RangeError("container must be one of `raw`, `deflate`, `gzip`");if(void 0!==l&&"string"!=typeof l)throw new TypeError("fileName must be a string");if(this.fileName=l||"",this.z=new ZStream,this.deflate=new Deflate(this.z,n,0),s){if("deflate"!==o)throw new TypeError("Can only provide a dictionary for `deflate` containers.");const t=u8ArrayFromBufferSource(s);if(!t)throw new TypeError("dictionary must be an ArrayBuffer or buffer view");this.dictChecksum=adler32(t),this.deflate.deflateSetDictionary(t)}this.format=o,"gzip"===this.format&&(this.checksum=0)}buildZlibHeader(){let t=2,i=1;0!==this.dictChecksum&&(t+=4,i=PRESET_DICT);const a=new ArrayBuffer(t),n=new DataView(a);return n.setUint16(0,30720|i),0!==this.dictChecksum&&n.setUint32(2,this.dictChecksum),new Uint8Array(a)}buildGZipHeader(){let t=0,i=[];this.fileName.length>0&&(t|=8,i=Array.from(this.fileName).map((t=>{const i=t.charCodeAt(0);return i>255?95:i})),i.push(0));const a=new ArrayBuffer(10+i.length),n=new DataView(a);n.setUint16(0,GZIP_ID1<<8|GZIP_ID2),n.setUint16(2,Z_DEFLATED<<8|t);const o=Math.floor(Date.now()/1e3);n.setUint32(4,o,!0),n.setUint16(8,255);const s=new Uint8Array(a);return i.length&&s.set(i,10),s}buildTrailer(){const t="gzip"===this.format,i=new ArrayBuffer(t?8:4),a=new DataView(i);return a.setUint32(0,this.checksum,t),t&&a.setUint32(4,this.origSize,!0),new Uint8Array(i)}append(t){const i=[],a=u8ArrayFromBufferSource(t);if(!(a instanceof Uint8Array))throw new TypeError("data must be an ArrayBuffer or buffer view");if(!a.length)return i;"gzip"!==this.format?this.checksum=adler32(a,this.checksum):this.checksum=crc32(a,this.checksum),this.origSize+=a.length;const{deflate:n,z:o}=this;o.next_in_index=0,o.next_in=a,o.avail_in=a.length,1===n.status&&("deflate"===this.format?i.push(this.buildZlibHeader()):"gzip"===this.format&&i.push(this.buildGZipHeader()));do{o.next_out_index=0,o.avail_out=OUTPUT_BUFSIZE;if(0!==n.deflate(0))throw new Error("deflating: "+o.msg);o.next_out_index&&i.push(new Uint8Array(o.next_out.subarray(0,o.next_out_index)))}while(o.avail_in>0||0===o.avail_out);return i}finish(){const t=[],{deflate:i,z:a}=this;if(1===i.status)throw new Error("Cannot call finish before at least 1 call to append");do{a.next_out_index=0,a.avail_out=OUTPUT_BUFSIZE;const n=i.deflate(4);if(1!==n&&0!==n)throw new Error("deflating: "+a.msg);OUTPUT_BUFSIZE-a.avail_out>0&&t.push(new Uint8Array(a.next_out.subarray(0,a.next_out_index)))}while(a.avail_in>0||0===a.avail_out);return"raw"!==this.format&&t.push(this.buildTrailer()),t}}const decContext=Symbol("decContext"),decTransform$1=Symbol("decTransform");class DecompressionTransformer{constructor(t){this.inflater_=t}transform(t,i){if(!(t instanceof ArrayBuffer||ArrayBuffer.isView(t)))throw new TypeError("Input data must be a BufferSource");const a=this.inflater_.append(t);for(const n of a)i.enqueue(n)}flush(t){const i=this.inflater_.finish();if(!i.success){if(!i.complete)throw new Error("Unexpected EOF during decompression");if("mismatch"===i.checksum)throw new Error("Data integrity check failed");if("mismatch"===i.fileSize)throw new Error("Data size check failed");throw new Error("Decompression error")}}}class DecompressionStream{constructor(t){if("deflate"!==t&&"gzip"!==t)throw new TypeError("format must be one of `deflate`, `gzip`");this[decContext]=new Inflater,this[decTransform$1]=new TransformStream(new DecompressionTransformer(this[decContext]))}get readable(){return this[decTransform$1].readable}get writable(){return this[decTransform$1].writable}}const comContext=Symbol("comContext"),comTransform=Symbol("comTransform");class CompressionTransformer{constructor(t){this.deflater_=t}transform(t,i){if(!(t instanceof ArrayBuffer||ArrayBuffer.isView(t)))throw new TypeError("Input data must be a BufferSource");const a=this.deflater_.append(t);for(const n of a)i.enqueue(n)}flush(t){const i=this.deflater_.finish();for(const a of i)t.enqueue(a)}}class CompressionStream{constructor(t){if("deflate"!==t&&"gzip"!==t)throw new TypeError("format must be one of `deflate`, `gzip`");this[comContext]=new Deflater({format:t}),this[comTransform]=new TransformStream(new CompressionTransformer(this[comContext]))}get readable(){return this[comTransform].readable}get writable(){return this[comTransform].writable}}function getGlobal(){return"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:void 0}function getGlobalValue(t){const i=getGlobal();let a;return void 0!==i&&(a=i[t]),a}function getGlobalOrContextualValue(name){const global=getGlobal();let value;if(void 0!==global&&(value=global[name]),void 0===value)try{value=eval(name)}catch(e){}return value}function hasCompleteStreamsImplementation(){const t=getGlobalValue("ReadableStream"),i=getGlobalValue("WritableStream"),a=getGlobalValue("TransformStream"),n=getGlobalValue("ByteLengthQueuingStrategy"),o=getGlobalValue("CountQueuingStrategy"),isFunc=t=>"function"==typeof t;if(!(isFunc(t)&&isFunc(i)&&isFunc(a)&&isFunc(n)&&isFunc(o)))return!1;try{const i=new t({type:"bytes"}).getReader({mode:"byob"});if(null==i||"object"!=typeof i)return!1}catch(s){return!1}return!0}function installStardazedStreams(){const t=getGlobal();if(!t)return!1;if(hasCompleteStreamsImplementation())return!1;const i=getGlobalOrContextualValue("fetch"),a=getGlobalOrContextualValue("Response"),n=getGlobalValue("ReadableStream");if(i&&a){const o=createAdaptedFetch(i,a,n,SDReadableStream,readableStreamTee),s=createAdaptedResponse(a,n,SDReadableStream,readableStreamTee);t.fetch=o,t.Response=s}return t.ReadableStream=SDReadableStream,t.WritableStream=WritableStream,t.TransformStream=TransformStream$1,t.ByteLengthQueuingStrategy=ByteLengthQueuingStrategy,t.CountQueuingStrategy=CountQueuingStrategy,!0}function installEncodingStreams(t){const i=getGlobal();if(!i)return;const a=getGlobalValue("TextDecoderStream");(t||"function"!=typeof a)&&(i.TextDecoderStream=TextDecoderStream);const n=getGlobalValue("TextEncoderStream");(t||"function"!=typeof n)&&(i.TextEncoderStream=TextEncoderStream)}function installCompressionStreams(t){const i=getGlobal();if(!i)return;const a=getGlobalValue("CompressionStream");(t||"function"!=typeof a)&&(i.CompressionStream=CompressionStream);const n=getGlobalValue("DecompressionStream");(t||"function"!=typeof n)&&(i.DecompressionStream=DecompressionStream)}const overwritten=installStardazedStreams();installEncodingStreams(overwritten),installCompressionStreams(overwritten)})();
